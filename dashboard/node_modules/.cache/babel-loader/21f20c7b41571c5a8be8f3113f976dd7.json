{"ast":null,"code":"/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { assert, clone, createHashMap, isFunction, keys, map, reduce } from 'zrender/lib/core/util.js';\nimport { parseDataValue } from './helper/dataValueHelper.js';\nimport { shouldRetrieveDataByName } from './Source.js';\nvar UNDEFINED = 'undefined';\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nexport var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nexport var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nexport var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nexport var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;\n/**\r\n * Multi dimensional data store\r\n */\n\nvar dataCtors = {\n  'float': CtorFloat64Array,\n  'int': CtorInt32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': CtorFloat64Array\n};\nvar defaultDimValueGetters;\n\nfunction getIndicesCtor(rawCount) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\n;\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n\n;\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nfunction prepareStore(store, dimIdx, dimType, end, append) {\n  var DataCtor = dataCtors[dimType || 'float'];\n\n  if (append) {\n    var oldStore = store[dimIdx];\n    var oldLen = oldStore && oldStore.length;\n\n    if (!(oldLen === end)) {\n      var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n\n      for (var j = 0; j < oldLen; j++) {\n        newStore[j] = oldStore[j];\n      }\n\n      store[dimIdx] = newStore;\n    }\n  } else {\n    store[dimIdx] = new DataCtor(end);\n  }\n}\n\n;\n/**\r\n * Basically, DataStore API keep immutable.\r\n */\n\nvar DataStore =\n/** @class */\nfunction () {\n  function DataStore() {\n    this._chunks = []; // It will not be calculated util needed.\n\n    this._rawExtent = [];\n    this._extent = [];\n    this._count = 0;\n    this._rawCount = 0;\n    this._calcDimNameToIdx = createHashMap();\n  }\n  /**\r\n   * Initialize from data\r\n   */\n\n\n  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isFunction(provider.getItem) && isFunction(provider.count), 'Inavlid data provider.');\n    }\n\n    this._provider = provider; // Clear\n\n    this._chunks = [];\n    this._indices = null;\n    this.getRawIndex = this._getRawIdxIdentity;\n    var source = provider.getSource();\n    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat]; // Default dim value getter\n\n    this._dimValueGetter = dimValueGetter || defaultGetter; // Reset raw extent.\n\n    this._rawExtent = [];\n    var willRetrieveDataByName = shouldRetrieveDataByName(source);\n    this._dimensions = map(inputDimensions, function (dim) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (willRetrieveDataByName) {\n          assert(dim.property != null);\n        }\n      }\n\n      return {\n        // Only pick these two props. Not leak other properties like orderMeta.\n        type: dim.type,\n        property: dim.property\n      };\n    });\n\n    this._initDataFromProvider(0, provider.count());\n  };\n\n  DataStore.prototype.getProvider = function () {\n    return this._provider;\n  };\n  /**\r\n   * Caution: even when a `source` instance owned by a series, the created data store\r\n   * may still be shared by different sereis (the source hash does not use all `source`\r\n   * props, see `sourceManager`). In this case, the `source` props that are not used in\r\n   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and\r\n   * thus should not be fetch here.\r\n   */\n\n\n  DataStore.prototype.getSource = function () {\n    return this._provider.getSource();\n  };\n  /**\r\n   * @caution Only used in dataStack.\r\n   */\n\n\n  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {\n    var calcDimNameToIdx = this._calcDimNameToIdx;\n    var dimensions = this._dimensions;\n    var calcDimIdx = calcDimNameToIdx.get(dimName);\n\n    if (calcDimIdx != null) {\n      if (dimensions[calcDimIdx].type === type) {\n        return calcDimIdx;\n      }\n    } else {\n      calcDimIdx = dimensions.length;\n    }\n\n    dimensions[calcDimIdx] = {\n      type: type\n    };\n    calcDimNameToIdx.set(dimName, calcDimIdx);\n    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);\n    this._rawExtent[calcDimIdx] = getInitialExtent();\n    return calcDimIdx;\n  };\n\n  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {\n    var chunk = this._chunks[dimIdx];\n    var dim = this._dimensions[dimIdx];\n    var rawExtents = this._rawExtent;\n    var offset = dim.ordinalOffset || 0;\n    var len = chunk.length;\n\n    if (offset === 0) {\n      // We need to reset the rawExtent if collect is from start.\n      // Because this dimension may be guessed as number and calcuating a wrong extent.\n      rawExtents[dimIdx] = getInitialExtent();\n    }\n\n    var dimRawExtent = rawExtents[dimIdx]; // Parse from previous data offset. len may be changed after appendData\n\n    for (var i = offset; i < len; i++) {\n      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);\n      dimRawExtent[0] = Math.min(val, dimRawExtent[0]);\n      dimRawExtent[1] = Math.max(val, dimRawExtent[1]);\n    }\n\n    dim.ordinalMeta = ordinalMeta;\n    dim.ordinalOffset = len;\n    dim.type = 'ordinal'; // Force to be ordinal\n  };\n\n  DataStore.prototype.getOrdinalMeta = function (dimIdx) {\n    var dimInfo = this._dimensions[dimIdx];\n    var ordinalMeta = dimInfo.ordinalMeta;\n    return ordinalMeta;\n  };\n\n  DataStore.prototype.getDimensionProperty = function (dimIndex) {\n    var item = this._dimensions[dimIndex];\n    return item && item.property;\n  };\n  /**\r\n   * Caution: Can be only called on raw data (before `this._indices` created).\r\n   */\n\n\n  DataStore.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var provider = this._provider;\n    var start = this.count();\n    provider.appendData(data);\n    var end = provider.count();\n\n    if (!provider.persistent) {\n      end += start;\n    }\n\n    if (start < end) {\n      this._initDataFromProvider(start, end, true);\n    }\n\n    return [start, end];\n  };\n\n  DataStore.prototype.appendValues = function (values, minFillLen) {\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, minFillLen || 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      prepareStore(chunks, i, dim.type, end, true);\n    }\n\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start; // Store the data by dimensions\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);\n        chunks[dimIdx][idx] = val;\n        var dimRawExtent = rawExtent[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n    }\n\n    this._rawCount = this._count = end;\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  DataStore.prototype._initDataFromProvider = function (start, end, append) {\n    var provider = this._provider;\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var dimNames = map(dimensions, function (dim) {\n      return dim.property;\n    });\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[i]) {\n        rawExtent[i] = getInitialExtent();\n      }\n\n      prepareStore(chunks, i, dim.type, end, append);\n    }\n\n    if (provider.fillStorage) {\n      provider.fillStorage(start, end, chunks, rawExtent);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = provider.getItem(idx, dataItem); // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dimStorage = chunks[dimIdx]; // PENDING NULL is empty or zero\n\n          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtent[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n      }\n    }\n\n    if (!provider.persistent && provider.clean) {\n      // Clean unused data if data source is typed array.\n      provider.clean();\n    }\n\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = [];\n  };\n\n  DataStore.prototype.count = function () {\n    return this._count;\n  };\n  /**\r\n   * Get value. Return NaN if idx is out of range.\r\n   */\n\n\n  DataStore.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  DataStore.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n    var dimArr = [];\n\n    if (idx == null) {\n      idx = dimensions; // TODO get all from store?\n\n      dimensions = []; // All dimensions\n\n      for (var i = 0; i < this._dimensions.length; i++) {\n        dimArr.push(i);\n      }\n    } else {\n      dimArr = dimensions;\n    }\n\n    for (var i = 0, len = dimArr.length; i < len; i++) {\n      values.push(this.get(dimArr[i], idx));\n    }\n\n    return values;\n  };\n  /**\r\n   * @param dim concrete dim\r\n   */\n\n\n  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n  /**\r\n   * Get sum of data in one dimension\r\n   */\n\n\n  DataStore.prototype.getSum = function (dim) {\n    var dimData = this._chunks[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n  /**\r\n   * Get median of data in one dimension\r\n   */\n\n\n  DataStore.prototype.getMedian = function (dim) {\n    var dimDataArray = []; // map all data of one dimension\n\n    this.each([dim], function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    }); // TODO\n    // Use quick select?\n\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count(); // calculate median\n\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n  /**\r\n   * Retreive the index with given raw data index\r\n   */\n\n\n  DataStore.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    } // Indices are ascending\n\n\n    var indices = this._indices; // If rawIndex === dataIndex\n\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n  /**\r\n   * Retreive the index of nearest value\r\n   * @param dim\r\n   * @param value\r\n   * @param [maxDistance=Infinity]\r\n   * @return If and only if multiple indices has\r\n   *         the same value, they are put to the result.\r\n   */\n\n\n  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var chunks = this._chunks;\n    var dimData = chunks[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/SeriesData.js`.\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we chose the one that `diff >= 0` in this csae.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n\n  DataStore.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this._rawCount);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  };\n  /**\r\n   * Data filter.\r\n   */\n\n\n  DataStore.prototype.filter = function (dims, cb) {\n    if (!this._count) {\n      return this;\n    }\n\n    var newStore = this.clone();\n    var count = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dims.length;\n    var offset = 0;\n    var dim0 = dims[0];\n    var chunks = newStore._chunks;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = newStore.getRawIndex(i); // Simple optimization\n\n      if (dimSize === 0) {\n        keep = cb(i);\n      } else if (dimSize === 1) {\n        var val = chunks[dim0][rawIdx];\n        keep = cb(val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = chunks[dims[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(null, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < count) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  };\n  /**\r\n   * Select data in range. (For optimization of filter)\r\n   * (Manually inline code, support 5 million data filtering in data zoom.)\r\n   */\n\n\n  DataStore.prototype.selectRange = function (range) {\n    var newStore = this.clone();\n    var len = newStore._count;\n\n    if (!len) {\n      return this;\n    }\n\n    var dims = keys(range);\n    var dimSize = dims.length;\n\n    if (!dimSize) {\n      return this;\n    }\n\n    var originalCount = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dims[0];\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storeArr = newStore._chunks;\n    var quickFinished = false;\n\n    if (!newStore._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storeArr[dims[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storeArr[dims[0]];\n        var dimStorage2 = storeArr[dims[1]];\n        var min2 = range[dims[1]][0];\n        var max2 = range[dims[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = newStore.getRawIndex(i);\n          var val = storeArr[dims[0]][rawIndex]; // Do not filter NaN, see comment above.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = newStore.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dims[k];\n            var val = storeArr[dimk][rawIndex]; // Do not filter NaN, see comment above.\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = newStore.getRawIndex(i);\n          }\n        }\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < originalCount) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  }; // /**\n  //  * Data mapping to a plain array\n  //  */\n  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {\n  //     const result: any[] = [];\n  //     this.each(dims, function () {\n  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));\n  //     });\n  //     return result;\n  // }\n\n  /**\r\n   * Data mapping to a new List with given dimensions\r\n   */\n\n\n  DataStore.prototype.map = function (dims, cb) {\n    // TODO only clone picked chunks.\n    var target = this.clone(dims);\n\n    this._updateDims(target, dims, cb);\n\n    return target;\n  };\n  /**\r\n   * @caution Danger!! Only used in dataStack.\r\n   */\n\n\n  DataStore.prototype.modify = function (dims, cb) {\n    this._updateDims(this, dims, cb);\n  };\n\n  DataStore.prototype._updateDims = function (target, dims, cb) {\n    var targetChunks = target._chunks;\n    var tmpRetValue = [];\n    var dimSize = dims.length;\n    var dataCount = target.count();\n    var values = [];\n    var rawExtent = target._rawExtent;\n\n    for (var i = 0; i < dims.length; i++) {\n      rawExtent[dims[i]] = getInitialExtent();\n    }\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      var rawIndex = target.getRawIndex(dataIndex);\n\n      for (var k = 0; k < dimSize; k++) {\n        values[k] = targetChunks[dims[k]][rawIndex];\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(null, values);\n\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dims[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = targetChunks[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Large data down sampling using largest-triangle-three-buckets\r\n   * @param {string} valueDimension\r\n   * @param {number} targetCount\r\n   */\n\n\n  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {\n    var target = this.clone([valueDimension], true);\n    var targetStorage = target._chunks;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var sampledIndex = 0;\n    var frameSize = Math.floor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize) + 2); // First frame use the first data.\n\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart; // Find a point from current frame that construct a triangel with largest area with previous selected point\n      // And the average of next frame.\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        } // Calculate triangle area over three buckets\n\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    } // First frame use the last data.\n\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    target._count = sampledIndex;\n    target._indices = newIndices;\n    target.getRawIndex = this._getRawIdx;\n    return target;\n  };\n  /**\r\n   * Large data down sampling on given dimension\r\n   * @param sampleIndex Sample index for name and id\r\n   */\n\n\n  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var target = this.clone([dimension], true);\n    var targetStorage = target._chunks;\n    var frameValues = [];\n    var frameSize = Math.floor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data\n\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    target._count = offset;\n    target._indices = newIndices;\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n  /**\r\n   * Data iteration\r\n   * @param ctx default this\r\n   * @example\r\n   *  list.each('x', function (x, idx) {});\r\n   *  list.each(['x', 'y'], function (x, y, idx) {});\r\n   *  list.each(function (idx) {})\r\n   */\n\n\n  DataStore.prototype.each = function (dims, cb) {\n    if (!this._count) {\n      return;\n    }\n\n    var dimSize = dims.length;\n    var chunks = this._chunks;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      switch (dimSize) {\n        case 0:\n          cb(i);\n          break;\n\n        case 1:\n          cb(chunks[dims[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = chunks[dims[k]][rawIdx];\n          } // Index\n\n\n          value[k] = i;\n          cb.apply(null, value);\n      }\n    }\n  };\n  /**\r\n   * Get extent of data in one dimension\r\n   */\n\n\n  DataStore.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    var dimData = this._chunks[dim];\n    var initialExtent = getInitialExtent();\n\n    if (!dimData) {\n      return initialExtent;\n    } // Make more strict checkings to ensure hitting cache.\n\n\n    var currEnd = this.count(); // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n\n    var useRaw = !this._indices;\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\r\n   * Get raw data item\r\n   */\n\n\n  DataStore.prototype.getRawDataItem = function (idx) {\n    var rawIdx = this.getRawIndex(idx);\n\n    if (!this._provider.persistent) {\n      var val = [];\n      var chunks = this._chunks;\n\n      for (var i = 0; i < chunks.length; i++) {\n        val.push(chunks[i][rawIdx]);\n      }\n\n      return val;\n    } else {\n      return this._provider.getItem(rawIdx);\n    }\n  };\n  /**\r\n   * Clone shallow.\r\n   *\r\n   * @param clonedDims Determine which dims to clone. Will share the data if not specified.\r\n   */\n\n\n  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {\n    var target = new DataStore();\n    var chunks = this._chunks;\n    var clonedDimsMap = clonedDims && reduce(clonedDims, function (obj, dimIdx) {\n      obj[dimIdx] = true;\n      return obj;\n    }, {});\n\n    if (clonedDimsMap) {\n      for (var i = 0; i < chunks.length; i++) {\n        // Not clone if dim is not picked.\n        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);\n      }\n    } else {\n      target._chunks = chunks;\n    }\n\n    this._copyCommonProps(target);\n\n    if (!ignoreIndices) {\n      target._indices = this._cloneIndices();\n    }\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n\n  DataStore.prototype._copyCommonProps = function (target) {\n    target._count = this._count;\n    target._rawCount = this._rawCount;\n    target._provider = this._provider;\n    target._dimensions = this._dimensions;\n    target._extent = clone(this._extent);\n    target._rawExtent = clone(this._rawExtent);\n  };\n\n  DataStore.prototype._cloneIndices = function () {\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n      var indices = void 0;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          indices[i] = this._indices[i];\n        }\n      } else {\n        indices = new Ctor(this._indices);\n      }\n\n      return indices;\n    }\n\n    return null;\n  };\n\n  DataStore.prototype._getRawIdxIdentity = function (idx) {\n    return idx;\n  };\n\n  DataStore.prototype._getRawIdx = function (idx) {\n    if (idx < this._count && idx >= 0) {\n      return this._indices[idx];\n    }\n\n    return -1;\n  };\n\n  DataStore.prototype._updateGetRawIdx = function () {\n    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;\n  };\n\n  DataStore.internalField = function () {\n    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {\n      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);\n    }\n\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function objectRows(dataItem, property, dataIndex, dimIndex) {\n        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function original(dataItem, property, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n        return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n        : value, this._dimensions[dimIndex]);\n      },\n      typedArray: function typedArray(dataItem, property, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n  }();\n\n  return DataStore;\n}();\n\nexport default DataStore;","map":{"version":3,"sources":["D:/fl-carla/node_modules/echarts/lib/data/DataStore.js"],"names":["assert","clone","createHashMap","isFunction","keys","map","reduce","parseDataValue","shouldRetrieveDataByName","UNDEFINED","CtorUint32Array","Uint32Array","Array","CtorUint16Array","Uint16Array","CtorInt32Array","Int32Array","CtorFloat64Array","Float64Array","dataCtors","defaultDimValueGetters","getIndicesCtor","rawCount","getInitialExtent","Infinity","cloneChunk","originalChunk","Ctor","constructor","slice","prepareStore","store","dimIdx","dimType","end","append","DataCtor","oldStore","oldLen","length","newStore","j","DataStore","_chunks","_rawExtent","_extent","_count","_rawCount","_calcDimNameToIdx","prototype","initData","provider","inputDimensions","dimValueGetter","process","env","NODE_ENV","getItem","count","_provider","_indices","getRawIndex","_getRawIdxIdentity","source","getSource","defaultGetter","defaultDimValueGetter","sourceFormat","_dimValueGetter","willRetrieveDataByName","_dimensions","dim","property","type","_initDataFromProvider","getProvider","ensureCalculationDimension","dimName","calcDimNameToIdx","dimensions","calcDimIdx","get","set","collectOrdinalMeta","ordinalMeta","chunk","rawExtents","offset","ordinalOffset","len","dimRawExtent","i","val","parseAndCollect","Math","min","max","getOrdinalMeta","dimInfo","getDimensionProperty","dimIndex","item","appendData","data","start","persistent","appendValues","values","minFillLen","chunks","dimLen","rawExtent","emptyDataItem","idx","sourceIdx","arrayRows","call","dimNames","fillStorage","dataItem","dimStorage","clean","NaN","dimStore","getValues","dimArr","push","getByRawIndex","rawIdx","getSum","dimData","sum","value","isNaN","getMedian","dimDataArray","each","sortedDimDataArray","sort","a","b","indexOfRawIndex","rawIndex","indices","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","minDist","minDiff","nearestIndicesLen","dataIndex","diff","dist","abs","getIndices","newIndices","thisCount","buffer","filter","dims","cb","dimSize","dim0","keep","k","apply","_updateGetRawIdx","selectRange","range","originalCount","storeArr","quickFinished","dimStorage2","min2","max2","val2","dimk","target","_updateDims","modify","targetChunks","tmpRetValue","dataCount","retValue","rawExtentOnDim","lttbDownSample","valueDimension","rate","targetStorage","sampledIndex","frameSize","floor","currentRawIndex","maxArea","area","nextRawIndex","ceil","nextFrameStart","nextFrameEnd","avgX","avgY","y","frameStart","frameEnd","pointAX","pointAY","_getRawIdx","downSample","dimension","sampleValue","sampleIndex","frameValues","dataIdx","sampleFrameIdx","getDataExtent","initialExtent","currEnd","useRaw","dimExtent","getRawDataItem","clonedDims","ignoreIndices","clonedDimsMap","obj","_copyCommonProps","_cloneIndices","internalField","getDimValueSimply","objectRows","keyedColumns","original","typedArray"],"mappings":"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","sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport { assert, clone, createHashMap, isFunction, keys, map, reduce } from 'zrender/lib/core/util.js';\r\nimport { parseDataValue } from './helper/dataValueHelper.js';\r\nimport { shouldRetrieveDataByName } from './Source.js';\r\nvar UNDEFINED = 'undefined';\r\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\r\n// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\r\n// different from the Ctor of typed array.\r\n\r\nexport var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\r\nexport var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\r\nexport var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\r\nexport var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;\r\n/**\r\n * Multi dimensional data store\r\n */\r\n\r\nvar dataCtors = {\r\n  'float': CtorFloat64Array,\r\n  'int': CtorInt32Array,\r\n  // Ordinal data type can be string or int\r\n  'ordinal': Array,\r\n  'number': Array,\r\n  'time': CtorFloat64Array\r\n};\r\nvar defaultDimValueGetters;\r\n\r\nfunction getIndicesCtor(rawCount) {\r\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\r\n  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\r\n}\r\n\r\n;\r\n\r\nfunction getInitialExtent() {\r\n  return [Infinity, -Infinity];\r\n}\r\n\r\n;\r\n\r\nfunction cloneChunk(originalChunk) {\r\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\r\n\r\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\r\n}\r\n\r\nfunction prepareStore(store, dimIdx, dimType, end, append) {\r\n  var DataCtor = dataCtors[dimType || 'float'];\r\n\r\n  if (append) {\r\n    var oldStore = store[dimIdx];\r\n    var oldLen = oldStore && oldStore.length;\r\n\r\n    if (!(oldLen === end)) {\r\n      var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable\r\n      // within the initial chunkSize.\r\n\r\n      for (var j = 0; j < oldLen; j++) {\r\n        newStore[j] = oldStore[j];\r\n      }\r\n\r\n      store[dimIdx] = newStore;\r\n    }\r\n  } else {\r\n    store[dimIdx] = new DataCtor(end);\r\n  }\r\n}\r\n\r\n;\r\n/**\r\n * Basically, DataStore API keep immutable.\r\n */\r\n\r\nvar DataStore =\r\n/** @class */\r\nfunction () {\r\n  function DataStore() {\r\n    this._chunks = []; // It will not be calculated util needed.\r\n\r\n    this._rawExtent = [];\r\n    this._extent = [];\r\n    this._count = 0;\r\n    this._rawCount = 0;\r\n    this._calcDimNameToIdx = createHashMap();\r\n  }\r\n  /**\r\n   * Initialize from data\r\n   */\r\n\r\n\r\n  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assert(isFunction(provider.getItem) && isFunction(provider.count), 'Inavlid data provider.');\r\n    }\r\n\r\n    this._provider = provider; // Clear\r\n\r\n    this._chunks = [];\r\n    this._indices = null;\r\n    this.getRawIndex = this._getRawIdxIdentity;\r\n    var source = provider.getSource();\r\n    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat]; // Default dim value getter\r\n\r\n    this._dimValueGetter = dimValueGetter || defaultGetter; // Reset raw extent.\r\n\r\n    this._rawExtent = [];\r\n    var willRetrieveDataByName = shouldRetrieveDataByName(source);\r\n    this._dimensions = map(inputDimensions, function (dim) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (willRetrieveDataByName) {\r\n          assert(dim.property != null);\r\n        }\r\n      }\r\n\r\n      return {\r\n        // Only pick these two props. Not leak other properties like orderMeta.\r\n        type: dim.type,\r\n        property: dim.property\r\n      };\r\n    });\r\n\r\n    this._initDataFromProvider(0, provider.count());\r\n  };\r\n\r\n  DataStore.prototype.getProvider = function () {\r\n    return this._provider;\r\n  };\r\n  /**\r\n   * Caution: even when a `source` instance owned by a series, the created data store\r\n   * may still be shared by different sereis (the source hash does not use all `source`\r\n   * props, see `sourceManager`). In this case, the `source` props that are not used in\r\n   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and\r\n   * thus should not be fetch here.\r\n   */\r\n\r\n\r\n  DataStore.prototype.getSource = function () {\r\n    return this._provider.getSource();\r\n  };\r\n  /**\r\n   * @caution Only used in dataStack.\r\n   */\r\n\r\n\r\n  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {\r\n    var calcDimNameToIdx = this._calcDimNameToIdx;\r\n    var dimensions = this._dimensions;\r\n    var calcDimIdx = calcDimNameToIdx.get(dimName);\r\n\r\n    if (calcDimIdx != null) {\r\n      if (dimensions[calcDimIdx].type === type) {\r\n        return calcDimIdx;\r\n      }\r\n    } else {\r\n      calcDimIdx = dimensions.length;\r\n    }\r\n\r\n    dimensions[calcDimIdx] = {\r\n      type: type\r\n    };\r\n    calcDimNameToIdx.set(dimName, calcDimIdx);\r\n    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);\r\n    this._rawExtent[calcDimIdx] = getInitialExtent();\r\n    return calcDimIdx;\r\n  };\r\n\r\n  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {\r\n    var chunk = this._chunks[dimIdx];\r\n    var dim = this._dimensions[dimIdx];\r\n    var rawExtents = this._rawExtent;\r\n    var offset = dim.ordinalOffset || 0;\r\n    var len = chunk.length;\r\n\r\n    if (offset === 0) {\r\n      // We need to reset the rawExtent if collect is from start.\r\n      // Because this dimension may be guessed as number and calcuating a wrong extent.\r\n      rawExtents[dimIdx] = getInitialExtent();\r\n    }\r\n\r\n    var dimRawExtent = rawExtents[dimIdx]; // Parse from previous data offset. len may be changed after appendData\r\n\r\n    for (var i = offset; i < len; i++) {\r\n      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);\r\n      dimRawExtent[0] = Math.min(val, dimRawExtent[0]);\r\n      dimRawExtent[1] = Math.max(val, dimRawExtent[1]);\r\n    }\r\n\r\n    dim.ordinalMeta = ordinalMeta;\r\n    dim.ordinalOffset = len;\r\n    dim.type = 'ordinal'; // Force to be ordinal\r\n  };\r\n\r\n  DataStore.prototype.getOrdinalMeta = function (dimIdx) {\r\n    var dimInfo = this._dimensions[dimIdx];\r\n    var ordinalMeta = dimInfo.ordinalMeta;\r\n    return ordinalMeta;\r\n  };\r\n\r\n  DataStore.prototype.getDimensionProperty = function (dimIndex) {\r\n    var item = this._dimensions[dimIndex];\r\n    return item && item.property;\r\n  };\r\n  /**\r\n   * Caution: Can be only called on raw data (before `this._indices` created).\r\n   */\r\n\r\n\r\n  DataStore.prototype.appendData = function (data) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assert(!this._indices, 'appendData can only be called on raw data.');\r\n    }\r\n\r\n    var provider = this._provider;\r\n    var start = this.count();\r\n    provider.appendData(data);\r\n    var end = provider.count();\r\n\r\n    if (!provider.persistent) {\r\n      end += start;\r\n    }\r\n\r\n    if (start < end) {\r\n      this._initDataFromProvider(start, end, true);\r\n    }\r\n\r\n    return [start, end];\r\n  };\r\n\r\n  DataStore.prototype.appendValues = function (values, minFillLen) {\r\n    var chunks = this._chunks;\r\n    var dimensions = this._dimensions;\r\n    var dimLen = dimensions.length;\r\n    var rawExtent = this._rawExtent;\r\n    var start = this.count();\r\n    var end = start + Math.max(values.length, minFillLen || 0);\r\n\r\n    for (var i = 0; i < dimLen; i++) {\r\n      var dim = dimensions[i];\r\n      prepareStore(chunks, i, dim.type, end, true);\r\n    }\r\n\r\n    var emptyDataItem = [];\r\n\r\n    for (var idx = start; idx < end; idx++) {\r\n      var sourceIdx = idx - start; // Store the data by dimensions\r\n\r\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\r\n        var dim = dimensions[dimIdx];\r\n        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);\r\n        chunks[dimIdx][idx] = val;\r\n        var dimRawExtent = rawExtent[dimIdx];\r\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\r\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\r\n      }\r\n    }\r\n\r\n    this._rawCount = this._count = end;\r\n    return {\r\n      start: start,\r\n      end: end\r\n    };\r\n  };\r\n\r\n  DataStore.prototype._initDataFromProvider = function (start, end, append) {\r\n    var provider = this._provider;\r\n    var chunks = this._chunks;\r\n    var dimensions = this._dimensions;\r\n    var dimLen = dimensions.length;\r\n    var rawExtent = this._rawExtent;\r\n    var dimNames = map(dimensions, function (dim) {\r\n      return dim.property;\r\n    });\r\n\r\n    for (var i = 0; i < dimLen; i++) {\r\n      var dim = dimensions[i];\r\n\r\n      if (!rawExtent[i]) {\r\n        rawExtent[i] = getInitialExtent();\r\n      }\r\n\r\n      prepareStore(chunks, i, dim.type, end, append);\r\n    }\r\n\r\n    if (provider.fillStorage) {\r\n      provider.fillStorage(start, end, chunks, rawExtent);\r\n    } else {\r\n      var dataItem = [];\r\n\r\n      for (var idx = start; idx < end; idx++) {\r\n        // NOTICE: Try not to write things into dataItem\r\n        dataItem = provider.getItem(idx, dataItem); // Each data item is value\r\n        // [1, 2]\r\n        // 2\r\n        // Bar chart, line chart which uses category axis\r\n        // only gives the 'y' value. 'x' value is the indices of category\r\n        // Use a tempValue to normalize the value to be a (x, y) value\r\n        // Store the data by dimensions\r\n\r\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\r\n          var dimStorage = chunks[dimIdx]; // PENDING NULL is empty or zero\r\n\r\n          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);\r\n\r\n          dimStorage[idx] = val;\r\n          var dimRawExtent = rawExtent[dimIdx];\r\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\r\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!provider.persistent && provider.clean) {\r\n      // Clean unused data if data source is typed array.\r\n      provider.clean();\r\n    }\r\n\r\n    this._rawCount = this._count = end; // Reset data extent\r\n\r\n    this._extent = [];\r\n  };\r\n\r\n  DataStore.prototype.count = function () {\r\n    return this._count;\r\n  };\r\n  /**\r\n   * Get value. Return NaN if idx is out of range.\r\n   */\r\n\r\n\r\n  DataStore.prototype.get = function (dim, idx) {\r\n    if (!(idx >= 0 && idx < this._count)) {\r\n      return NaN;\r\n    }\r\n\r\n    var dimStore = this._chunks[dim];\r\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\r\n  };\r\n\r\n  DataStore.prototype.getValues = function (dimensions, idx) {\r\n    var values = [];\r\n    var dimArr = [];\r\n\r\n    if (idx == null) {\r\n      idx = dimensions; // TODO get all from store?\r\n\r\n      dimensions = []; // All dimensions\r\n\r\n      for (var i = 0; i < this._dimensions.length; i++) {\r\n        dimArr.push(i);\r\n      }\r\n    } else {\r\n      dimArr = dimensions;\r\n    }\r\n\r\n    for (var i = 0, len = dimArr.length; i < len; i++) {\r\n      values.push(this.get(dimArr[i], idx));\r\n    }\r\n\r\n    return values;\r\n  };\r\n  /**\r\n   * @param dim concrete dim\r\n   */\r\n\r\n\r\n  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {\r\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\r\n      return NaN;\r\n    }\r\n\r\n    var dimStore = this._chunks[dim];\r\n    return dimStore ? dimStore[rawIdx] : NaN;\r\n  };\r\n  /**\r\n   * Get sum of data in one dimension\r\n   */\r\n\r\n\r\n  DataStore.prototype.getSum = function (dim) {\r\n    var dimData = this._chunks[dim];\r\n    var sum = 0;\r\n\r\n    if (dimData) {\r\n      for (var i = 0, len = this.count(); i < len; i++) {\r\n        var value = this.get(dim, i);\r\n\r\n        if (!isNaN(value)) {\r\n          sum += value;\r\n        }\r\n      }\r\n    }\r\n\r\n    return sum;\r\n  };\r\n  /**\r\n   * Get median of data in one dimension\r\n   */\r\n\r\n\r\n  DataStore.prototype.getMedian = function (dim) {\r\n    var dimDataArray = []; // map all data of one dimension\r\n\r\n    this.each([dim], function (val) {\r\n      if (!isNaN(val)) {\r\n        dimDataArray.push(val);\r\n      }\r\n    }); // TODO\r\n    // Use quick select?\r\n\r\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\r\n      return a - b;\r\n    });\r\n    var len = this.count(); // calculate median\r\n\r\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\r\n  };\r\n  /**\r\n   * Retreive the index with given raw data index\r\n   */\r\n\r\n\r\n  DataStore.prototype.indexOfRawIndex = function (rawIndex) {\r\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\r\n      return -1;\r\n    }\r\n\r\n    if (!this._indices) {\r\n      return rawIndex;\r\n    } // Indices are ascending\r\n\r\n\r\n    var indices = this._indices; // If rawIndex === dataIndex\r\n\r\n    var rawDataIndex = indices[rawIndex];\r\n\r\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\r\n      return rawIndex;\r\n    }\r\n\r\n    var left = 0;\r\n    var right = this._count - 1;\r\n\r\n    while (left <= right) {\r\n      var mid = (left + right) / 2 | 0;\r\n\r\n      if (indices[mid] < rawIndex) {\r\n        left = mid + 1;\r\n      } else if (indices[mid] > rawIndex) {\r\n        right = mid - 1;\r\n      } else {\r\n        return mid;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  };\r\n  /**\r\n   * Retreive the index of nearest value\r\n   * @param dim\r\n   * @param value\r\n   * @param [maxDistance=Infinity]\r\n   * @return If and only if multiple indices has\r\n   *         the same value, they are put to the result.\r\n   */\r\n\r\n\r\n  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {\r\n    var chunks = this._chunks;\r\n    var dimData = chunks[dim];\r\n    var nearestIndices = [];\r\n\r\n    if (!dimData) {\r\n      return nearestIndices;\r\n    }\r\n\r\n    if (maxDistance == null) {\r\n      maxDistance = Infinity;\r\n    }\r\n\r\n    var minDist = Infinity;\r\n    var minDiff = -1;\r\n    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/SeriesData.js`.\r\n\r\n    for (var i = 0, len = this.count(); i < len; i++) {\r\n      var dataIndex = this.getRawIndex(i);\r\n      var diff = value - dimData[dataIndex];\r\n      var dist = Math.abs(diff);\r\n\r\n      if (dist <= maxDistance) {\r\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\r\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\r\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\r\n        // So we chose the one that `diff >= 0` in this csae.\r\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\r\n        // should be push to `nearestIndices`.\r\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\r\n          minDist = dist;\r\n          minDiff = diff;\r\n          nearestIndicesLen = 0;\r\n        }\r\n\r\n        if (diff === minDiff) {\r\n          nearestIndices[nearestIndicesLen++] = i;\r\n        }\r\n      }\r\n    }\r\n\r\n    nearestIndices.length = nearestIndicesLen;\r\n    return nearestIndices;\r\n  };\r\n\r\n  DataStore.prototype.getIndices = function () {\r\n    var newIndices;\r\n    var indices = this._indices;\r\n\r\n    if (indices) {\r\n      var Ctor = indices.constructor;\r\n      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\r\n\r\n      if (Ctor === Array) {\r\n        newIndices = new Ctor(thisCount);\r\n\r\n        for (var i = 0; i < thisCount; i++) {\r\n          newIndices[i] = indices[i];\r\n        }\r\n      } else {\r\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\r\n      }\r\n    } else {\r\n      var Ctor = getIndicesCtor(this._rawCount);\r\n      newIndices = new Ctor(this.count());\r\n\r\n      for (var i = 0; i < newIndices.length; i++) {\r\n        newIndices[i] = i;\r\n      }\r\n    }\r\n\r\n    return newIndices;\r\n  };\r\n  /**\r\n   * Data filter.\r\n   */\r\n\r\n\r\n  DataStore.prototype.filter = function (dims, cb) {\r\n    if (!this._count) {\r\n      return this;\r\n    }\r\n\r\n    var newStore = this.clone();\r\n    var count = newStore.count();\r\n    var Ctor = getIndicesCtor(newStore._rawCount);\r\n    var newIndices = new Ctor(count);\r\n    var value = [];\r\n    var dimSize = dims.length;\r\n    var offset = 0;\r\n    var dim0 = dims[0];\r\n    var chunks = newStore._chunks;\r\n\r\n    for (var i = 0; i < count; i++) {\r\n      var keep = void 0;\r\n      var rawIdx = newStore.getRawIndex(i); // Simple optimization\r\n\r\n      if (dimSize === 0) {\r\n        keep = cb(i);\r\n      } else if (dimSize === 1) {\r\n        var val = chunks[dim0][rawIdx];\r\n        keep = cb(val, i);\r\n      } else {\r\n        var k = 0;\r\n\r\n        for (; k < dimSize; k++) {\r\n          value[k] = chunks[dims[k]][rawIdx];\r\n        }\r\n\r\n        value[k] = i;\r\n        keep = cb.apply(null, value);\r\n      }\r\n\r\n      if (keep) {\r\n        newIndices[offset++] = rawIdx;\r\n      }\r\n    } // Set indices after filtered.\r\n\r\n\r\n    if (offset < count) {\r\n      newStore._indices = newIndices;\r\n    }\r\n\r\n    newStore._count = offset; // Reset data extent\r\n\r\n    newStore._extent = [];\r\n\r\n    newStore._updateGetRawIdx();\r\n\r\n    return newStore;\r\n  };\r\n  /**\r\n   * Select data in range. (For optimization of filter)\r\n   * (Manually inline code, support 5 million data filtering in data zoom.)\r\n   */\r\n\r\n\r\n  DataStore.prototype.selectRange = function (range) {\r\n    var newStore = this.clone();\r\n    var len = newStore._count;\r\n\r\n    if (!len) {\r\n      return this;\r\n    }\r\n\r\n    var dims = keys(range);\r\n    var dimSize = dims.length;\r\n\r\n    if (!dimSize) {\r\n      return this;\r\n    }\r\n\r\n    var originalCount = newStore.count();\r\n    var Ctor = getIndicesCtor(newStore._rawCount);\r\n    var newIndices = new Ctor(originalCount);\r\n    var offset = 0;\r\n    var dim0 = dims[0];\r\n    var min = range[dim0][0];\r\n    var max = range[dim0][1];\r\n    var storeArr = newStore._chunks;\r\n    var quickFinished = false;\r\n\r\n    if (!newStore._indices) {\r\n      // Extreme optimization for common case. About 2x faster in chrome.\r\n      var idx = 0;\r\n\r\n      if (dimSize === 1) {\r\n        var dimStorage = storeArr[dims[0]];\r\n\r\n        for (var i = 0; i < len; i++) {\r\n          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\r\n          // value indicates the line should be broken. But for the case like\r\n          // scatter plot, a data item with empty value will not be rendered,\r\n          // but the axis extent may be effected if some other dim of the data\r\n          // item has value. Fortunately it is not a significant negative effect.\r\n\r\n          if (val >= min && val <= max || isNaN(val)) {\r\n            newIndices[offset++] = idx;\r\n          }\r\n\r\n          idx++;\r\n        }\r\n\r\n        quickFinished = true;\r\n      } else if (dimSize === 2) {\r\n        var dimStorage = storeArr[dims[0]];\r\n        var dimStorage2 = storeArr[dims[1]];\r\n        var min2 = range[dims[1]][0];\r\n        var max2 = range[dims[1]][1];\r\n\r\n        for (var i = 0; i < len; i++) {\r\n          var val = dimStorage[i];\r\n          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.\r\n\r\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\r\n            newIndices[offset++] = idx;\r\n          }\r\n\r\n          idx++;\r\n        }\r\n\r\n        quickFinished = true;\r\n      }\r\n    }\r\n\r\n    if (!quickFinished) {\r\n      if (dimSize === 1) {\r\n        for (var i = 0; i < originalCount; i++) {\r\n          var rawIndex = newStore.getRawIndex(i);\r\n          var val = storeArr[dims[0]][rawIndex]; // Do not filter NaN, see comment above.\r\n\r\n          if (val >= min && val <= max || isNaN(val)) {\r\n            newIndices[offset++] = rawIndex;\r\n          }\r\n        }\r\n      } else {\r\n        for (var i = 0; i < originalCount; i++) {\r\n          var keep = true;\r\n          var rawIndex = newStore.getRawIndex(i);\r\n\r\n          for (var k = 0; k < dimSize; k++) {\r\n            var dimk = dims[k];\r\n            var val = storeArr[dimk][rawIndex]; // Do not filter NaN, see comment above.\r\n\r\n            if (val < range[dimk][0] || val > range[dimk][1]) {\r\n              keep = false;\r\n            }\r\n          }\r\n\r\n          if (keep) {\r\n            newIndices[offset++] = newStore.getRawIndex(i);\r\n          }\r\n        }\r\n      }\r\n    } // Set indices after filtered.\r\n\r\n\r\n    if (offset < originalCount) {\r\n      newStore._indices = newIndices;\r\n    }\r\n\r\n    newStore._count = offset; // Reset data extent\r\n\r\n    newStore._extent = [];\r\n\r\n    newStore._updateGetRawIdx();\r\n\r\n    return newStore;\r\n  }; // /**\r\n  //  * Data mapping to a plain array\r\n  //  */\r\n  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {\r\n  //     const result: any[] = [];\r\n  //     this.each(dims, function () {\r\n  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));\r\n  //     });\r\n  //     return result;\r\n  // }\r\n\r\n  /**\r\n   * Data mapping to a new List with given dimensions\r\n   */\r\n\r\n\r\n  DataStore.prototype.map = function (dims, cb) {\r\n    // TODO only clone picked chunks.\r\n    var target = this.clone(dims);\r\n\r\n    this._updateDims(target, dims, cb);\r\n\r\n    return target;\r\n  };\r\n  /**\r\n   * @caution Danger!! Only used in dataStack.\r\n   */\r\n\r\n\r\n  DataStore.prototype.modify = function (dims, cb) {\r\n    this._updateDims(this, dims, cb);\r\n  };\r\n\r\n  DataStore.prototype._updateDims = function (target, dims, cb) {\r\n    var targetChunks = target._chunks;\r\n    var tmpRetValue = [];\r\n    var dimSize = dims.length;\r\n    var dataCount = target.count();\r\n    var values = [];\r\n    var rawExtent = target._rawExtent;\r\n\r\n    for (var i = 0; i < dims.length; i++) {\r\n      rawExtent[dims[i]] = getInitialExtent();\r\n    }\r\n\r\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\r\n      var rawIndex = target.getRawIndex(dataIndex);\r\n\r\n      for (var k = 0; k < dimSize; k++) {\r\n        values[k] = targetChunks[dims[k]][rawIndex];\r\n      }\r\n\r\n      values[dimSize] = dataIndex;\r\n      var retValue = cb && cb.apply(null, values);\r\n\r\n      if (retValue != null) {\r\n        // a number or string (in oridinal dimension)?\r\n        if (typeof retValue !== 'object') {\r\n          tmpRetValue[0] = retValue;\r\n          retValue = tmpRetValue;\r\n        }\r\n\r\n        for (var i = 0; i < retValue.length; i++) {\r\n          var dim = dims[i];\r\n          var val = retValue[i];\r\n          var rawExtentOnDim = rawExtent[dim];\r\n          var dimStore = targetChunks[dim];\r\n\r\n          if (dimStore) {\r\n            dimStore[rawIndex] = val;\r\n          }\r\n\r\n          if (val < rawExtentOnDim[0]) {\r\n            rawExtentOnDim[0] = val;\r\n          }\r\n\r\n          if (val > rawExtentOnDim[1]) {\r\n            rawExtentOnDim[1] = val;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Large data down sampling using largest-triangle-three-buckets\r\n   * @param {string} valueDimension\r\n   * @param {number} targetCount\r\n   */\r\n\r\n\r\n  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {\r\n    var target = this.clone([valueDimension], true);\r\n    var targetStorage = target._chunks;\r\n    var dimStore = targetStorage[valueDimension];\r\n    var len = this.count();\r\n    var sampledIndex = 0;\r\n    var frameSize = Math.floor(1 / rate);\r\n    var currentRawIndex = this.getRawIndex(0);\r\n    var maxArea;\r\n    var area;\r\n    var nextRawIndex;\r\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize) + 2); // First frame use the first data.\r\n\r\n    newIndices[sampledIndex++] = currentRawIndex;\r\n\r\n    for (var i = 1; i < len - 1; i += frameSize) {\r\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\r\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\r\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\r\n      var avgY = 0;\r\n\r\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\r\n        var rawIndex = this.getRawIndex(idx);\r\n        var y = dimStore[rawIndex];\r\n\r\n        if (isNaN(y)) {\r\n          continue;\r\n        }\r\n\r\n        avgY += y;\r\n      }\r\n\r\n      avgY /= nextFrameEnd - nextFrameStart;\r\n      var frameStart = i;\r\n      var frameEnd = Math.min(i + frameSize, len);\r\n      var pointAX = i - 1;\r\n      var pointAY = dimStore[currentRawIndex];\r\n      maxArea = -1;\r\n      nextRawIndex = frameStart; // Find a point from current frame that construct a triangel with largest area with previous selected point\r\n      // And the average of next frame.\r\n\r\n      for (var idx = frameStart; idx < frameEnd; idx++) {\r\n        var rawIndex = this.getRawIndex(idx);\r\n        var y = dimStore[rawIndex];\r\n\r\n        if (isNaN(y)) {\r\n          continue;\r\n        } // Calculate triangle area over three buckets\r\n\r\n\r\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\r\n\r\n        if (area > maxArea) {\r\n          maxArea = area;\r\n          nextRawIndex = rawIndex; // Next a is this b\r\n        }\r\n      }\r\n\r\n      newIndices[sampledIndex++] = nextRawIndex;\r\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\r\n    } // First frame use the last data.\r\n\r\n\r\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\r\n    target._count = sampledIndex;\r\n    target._indices = newIndices;\r\n    target.getRawIndex = this._getRawIdx;\r\n    return target;\r\n  };\r\n  /**\r\n   * Large data down sampling on given dimension\r\n   * @param sampleIndex Sample index for name and id\r\n   */\r\n\r\n\r\n  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\r\n    var target = this.clone([dimension], true);\r\n    var targetStorage = target._chunks;\r\n    var frameValues = [];\r\n    var frameSize = Math.floor(1 / rate);\r\n    var dimStore = targetStorage[dimension];\r\n    var len = this.count();\r\n    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();\r\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));\r\n    var offset = 0;\r\n\r\n    for (var i = 0; i < len; i += frameSize) {\r\n      // Last frame\r\n      if (frameSize > len - i) {\r\n        frameSize = len - i;\r\n        frameValues.length = frameSize;\r\n      }\r\n\r\n      for (var k = 0; k < frameSize; k++) {\r\n        var dataIdx = this.getRawIndex(i + k);\r\n        frameValues[k] = dimStore[dataIdx];\r\n      }\r\n\r\n      var value = sampleValue(frameValues);\r\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data\r\n\r\n      dimStore[sampleFrameIdx] = value;\r\n\r\n      if (value < rawExtentOnDim[0]) {\r\n        rawExtentOnDim[0] = value;\r\n      }\r\n\r\n      if (value > rawExtentOnDim[1]) {\r\n        rawExtentOnDim[1] = value;\r\n      }\r\n\r\n      newIndices[offset++] = sampleFrameIdx;\r\n    }\r\n\r\n    target._count = offset;\r\n    target._indices = newIndices;\r\n\r\n    target._updateGetRawIdx();\r\n\r\n    return target;\r\n  };\r\n  /**\r\n   * Data iteration\r\n   * @param ctx default this\r\n   * @example\r\n   *  list.each('x', function (x, idx) {});\r\n   *  list.each(['x', 'y'], function (x, y, idx) {});\r\n   *  list.each(function (idx) {})\r\n   */\r\n\r\n\r\n  DataStore.prototype.each = function (dims, cb) {\r\n    if (!this._count) {\r\n      return;\r\n    }\r\n\r\n    var dimSize = dims.length;\r\n    var chunks = this._chunks;\r\n\r\n    for (var i = 0, len = this.count(); i < len; i++) {\r\n      var rawIdx = this.getRawIndex(i); // Simple optimization\r\n\r\n      switch (dimSize) {\r\n        case 0:\r\n          cb(i);\r\n          break;\r\n\r\n        case 1:\r\n          cb(chunks[dims[0]][rawIdx], i);\r\n          break;\r\n\r\n        case 2:\r\n          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);\r\n          break;\r\n\r\n        default:\r\n          var k = 0;\r\n          var value = [];\r\n\r\n          for (; k < dimSize; k++) {\r\n            value[k] = chunks[dims[k]][rawIdx];\r\n          } // Index\r\n\r\n\r\n          value[k] = i;\r\n          cb.apply(null, value);\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Get extent of data in one dimension\r\n   */\r\n\r\n\r\n  DataStore.prototype.getDataExtent = function (dim) {\r\n    // Make sure use concrete dim as cache name.\r\n    var dimData = this._chunks[dim];\r\n    var initialExtent = getInitialExtent();\r\n\r\n    if (!dimData) {\r\n      return initialExtent;\r\n    } // Make more strict checkings to ensure hitting cache.\r\n\r\n\r\n    var currEnd = this.count(); // Consider the most cases when using data zoom, `getDataExtent`\r\n    // happened before filtering. We cache raw extent, which is not\r\n    // necessary to be cleared and recalculated when restore data.\r\n\r\n    var useRaw = !this._indices;\r\n    var dimExtent;\r\n\r\n    if (useRaw) {\r\n      return this._rawExtent[dim].slice();\r\n    }\r\n\r\n    dimExtent = this._extent[dim];\r\n\r\n    if (dimExtent) {\r\n      return dimExtent.slice();\r\n    }\r\n\r\n    dimExtent = initialExtent;\r\n    var min = dimExtent[0];\r\n    var max = dimExtent[1];\r\n\r\n    for (var i = 0; i < currEnd; i++) {\r\n      var rawIdx = this.getRawIndex(i);\r\n      var value = dimData[rawIdx];\r\n      value < min && (min = value);\r\n      value > max && (max = value);\r\n    }\r\n\r\n    dimExtent = [min, max];\r\n    this._extent[dim] = dimExtent;\r\n    return dimExtent;\r\n  };\r\n  /**\r\n   * Get raw data item\r\n   */\r\n\r\n\r\n  DataStore.prototype.getRawDataItem = function (idx) {\r\n    var rawIdx = this.getRawIndex(idx);\r\n\r\n    if (!this._provider.persistent) {\r\n      var val = [];\r\n      var chunks = this._chunks;\r\n\r\n      for (var i = 0; i < chunks.length; i++) {\r\n        val.push(chunks[i][rawIdx]);\r\n      }\r\n\r\n      return val;\r\n    } else {\r\n      return this._provider.getItem(rawIdx);\r\n    }\r\n  };\r\n  /**\r\n   * Clone shallow.\r\n   *\r\n   * @param clonedDims Determine which dims to clone. Will share the data if not specified.\r\n   */\r\n\r\n\r\n  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {\r\n    var target = new DataStore();\r\n    var chunks = this._chunks;\r\n    var clonedDimsMap = clonedDims && reduce(clonedDims, function (obj, dimIdx) {\r\n      obj[dimIdx] = true;\r\n      return obj;\r\n    }, {});\r\n\r\n    if (clonedDimsMap) {\r\n      for (var i = 0; i < chunks.length; i++) {\r\n        // Not clone if dim is not picked.\r\n        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);\r\n      }\r\n    } else {\r\n      target._chunks = chunks;\r\n    }\r\n\r\n    this._copyCommonProps(target);\r\n\r\n    if (!ignoreIndices) {\r\n      target._indices = this._cloneIndices();\r\n    }\r\n\r\n    target._updateGetRawIdx();\r\n\r\n    return target;\r\n  };\r\n\r\n  DataStore.prototype._copyCommonProps = function (target) {\r\n    target._count = this._count;\r\n    target._rawCount = this._rawCount;\r\n    target._provider = this._provider;\r\n    target._dimensions = this._dimensions;\r\n    target._extent = clone(this._extent);\r\n    target._rawExtent = clone(this._rawExtent);\r\n  };\r\n\r\n  DataStore.prototype._cloneIndices = function () {\r\n    if (this._indices) {\r\n      var Ctor = this._indices.constructor;\r\n      var indices = void 0;\r\n\r\n      if (Ctor === Array) {\r\n        var thisCount = this._indices.length;\r\n        indices = new Ctor(thisCount);\r\n\r\n        for (var i = 0; i < thisCount; i++) {\r\n          indices[i] = this._indices[i];\r\n        }\r\n      } else {\r\n        indices = new Ctor(this._indices);\r\n      }\r\n\r\n      return indices;\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  DataStore.prototype._getRawIdxIdentity = function (idx) {\r\n    return idx;\r\n  };\r\n\r\n  DataStore.prototype._getRawIdx = function (idx) {\r\n    if (idx < this._count && idx >= 0) {\r\n      return this._indices[idx];\r\n    }\r\n\r\n    return -1;\r\n  };\r\n\r\n  DataStore.prototype._updateGetRawIdx = function () {\r\n    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;\r\n  };\r\n\r\n  DataStore.internalField = function () {\r\n    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {\r\n      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);\r\n    }\r\n\r\n    defaultDimValueGetters = {\r\n      arrayRows: getDimValueSimply,\r\n      objectRows: function (dataItem, property, dataIndex, dimIndex) {\r\n        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);\r\n      },\r\n      keyedColumns: getDimValueSimply,\r\n      original: function (dataItem, property, dataIndex, dimIndex) {\r\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\r\n        // If dataItem is an plain object with no value field, the let `value`\r\n        // will be assigned with the object, but it will be tread correctly\r\n        // in the `convertValue`.\r\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\r\n        return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\r\n        : value, this._dimensions[dimIndex]);\r\n      },\r\n      typedArray: function (dataItem, property, dataIndex, dimIndex) {\r\n        return dataItem[dimIndex];\r\n      }\r\n    };\r\n  }();\r\n\r\n  return DataStore;\r\n}();\r\n\r\nexport default DataStore;"]},"metadata":{},"sourceType":"module"}