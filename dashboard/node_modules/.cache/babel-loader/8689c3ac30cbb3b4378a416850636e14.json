{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport isValidNumber from '../isValid.js';\nimport parseDigits from '../helpers/parseDigits.js';\nimport matchPhoneNumberStringAgainstPhoneNumber from './matchPhoneNumberStringAgainstPhoneNumber.js';\nimport Metadata from '../metadata.js';\nimport getCountryByCallingCode from '../helpers/getCountryByCallingCode.js';\nimport { chooseFormatForNumber } from '../format.js';\nimport { startsWith, endsWith } from './util.js';\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\n\nexport default {\n  /**\r\n   * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n   */\n  POSSIBLE: function POSSIBLE(phoneNumber, candidate, metadata) {\n    return true;\n  },\n  /**\r\n   * Phone numbers accepted are \"possible\" and \"valid\".\r\n   * Numbers written in national format must have their national-prefix\r\n   * present if it is usually written for a number of this type.\r\n   */\n  VALID: function VALID(phoneNumber, candidate, metadata) {\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata)) {\n      return false;\n    } // Skipped for simplicity.\n    // return isNationalPrefixPresentIfRequired(phoneNumber, metadata)\n\n    return true;\n  },\n  /**\r\n   * Phone numbers accepted are \"valid\" and\r\n   * are grouped in a possible way for this locale. For example, a US number written as\r\n   * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n   * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n   * Numbers with more than one '/' symbol in the national significant number\r\n   * are also dropped at this level.\r\n   *\r\n   * Warning: This level might result in lower coverage especially for regions outside of\r\n   * country code \"+1\". If you are not sure about which level to use,\r\n   * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n   */\n  STRICT_GROUPING: function STRICT_GROUPING(phoneNumber, candidate, metadata, regExpCache) {\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, metadata)) {\n      return false;\n    }\n    return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsRemainGrouped, regExpCache);\n  },\n  /**\r\n   * Phone numbers accepted are \"valid\" and are grouped in the same way\r\n   * that we would have formatted it, or as a single block.\r\n   * For example, a US number written as \"650 2530000\" is not accepted\r\n   * at this leniency level, whereas \"650 253 0000\" or \"6502530000\" are.\r\n   * Numbers with more than one '/' symbol are also dropped at this level.\r\n   *\r\n   * Warning: This level might result in lower coverage especially for regions outside of\r\n   * country code \"+1\". If you are not sure about which level to use, email the discussion group\r\n   * libphonenumber-discuss@googlegroups.com.\r\n   */\n  EXACT_GROUPING: function EXACT_GROUPING(phoneNumber, candidate, metadata, regExpCache) {\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, metadata)) {\n      return false;\n    }\n    return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsAreExactlyPresent, regExpCache);\n  }\n};\nfunction containsOnlyValidXChars(phoneNumber, candidate, metadata) {\n  // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\n  // national significant number or (2) an extension sign, in which case they always precede the\n  // extension number. We assume a carrier code is more than 1 digit, so the first case has to\n  // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\n  // or 'X'. We ignore the character if it appears as the last character of the string.\n  for (var index = 0; index < candidate.length - 1; index++) {\n    var charAtIndex = candidate.charAt(index);\n    if (charAtIndex === 'x' || charAtIndex === 'X') {\n      var charAtNextIndex = candidate.charAt(index + 1);\n      if (charAtNextIndex === 'x' || charAtNextIndex === 'X') {\n        // This is the carrier code case, in which the 'X's always precede the national\n        // significant number.\n        index++;\n        if (matchPhoneNumberStringAgainstPhoneNumber(candidate.substring(index), phoneNumber, metadata) !== 'NSN_MATCH') {\n          return false;\n        } // This is the extension sign case, in which the 'x' or 'X' should always precede the\n        // extension number.\n      } else {\n        var ext = parseDigits(candidate.substring(index));\n        if (ext) {\n          if (phoneNumber.ext !== ext) {\n            return false;\n          }\n        } else {\n          if (phoneNumber.ext) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\nfunction isNationalPrefixPresentIfRequired(phoneNumber, _metadata) {\n  // First, check how we deduced the country code. If it was written in international format, then\n  // the national prefix is not required.\n  if (phoneNumber.__countryCallingCodeSource !== 'FROM_DEFAULT_COUNTRY') {\n    return true;\n  }\n  var metadata = new Metadata(_metadata);\n  metadata.selectNumberingPlan(phoneNumber.countryCallingCode);\n  var phoneNumberRegion = phoneNumber.country || getCountryByCallingCode(phoneNumber.countryCallingCode, phoneNumber.nationalNumber, metadata); // Check if a national prefix should be present when formatting this number.\n\n  var nationalNumber = phoneNumber.nationalNumber;\n  var format = chooseFormatForNumber(metadata.numberingPlan.formats(), nationalNumber); // To do this, we check that a national prefix formatting rule was present\n  // and that it wasn't just the first-group symbol ($1) with punctuation.\n\n  if (format.nationalPrefixFormattingRule()) {\n    if (metadata.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\n      // The national-prefix is optional in these cases, so we don't need to check if it was present.\n      return true;\n    }\n    if (!format.usesNationalPrefix()) {\n      // National Prefix not needed for this number.\n      return true;\n    }\n    return Boolean(phoneNumber.nationalPrefix);\n  }\n  return true;\n}\nexport function containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) {\n  var firstSlashInBodyIndex = candidate.indexOf('/');\n  if (firstSlashInBodyIndex < 0) {\n    // No slashes, this is okay.\n    return false;\n  } // Now look for a second one.\n\n  var secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1);\n  if (secondSlashInBodyIndex < 0) {\n    // Only one slash, this is okay.\n    return false;\n  } // If the first slash is after the country calling code, this is permitted.\n\n  var candidateHasCountryCode = phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITH_PLUS_SIGN' || phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITHOUT_PLUS_SIGN';\n  if (candidateHasCountryCode && parseDigits(candidate.substring(0, firstSlashInBodyIndex)) === phoneNumber.countryCallingCode) {\n    // Any more slashes and this is illegal.\n    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0;\n  }\n  return true;\n}\nfunction checkNumberGroupingIsValid(number, candidate, metadata, checkGroups, regExpCache) {\n  throw new Error('This part of code hasn\\'t been ported');\n  var normalizedCandidate = normalizeDigits(candidate, true\n  /* keep non-digits */);\n\n  var formattedNumberGroups = getNationalNumberGroups(metadata, number, null);\n  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\n    return true;\n  } // If this didn't pass, see if there are any alternate formats that match, and try them instead.\n\n  var alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode());\n  var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n  if (alternateFormats) {\n    for (var _iterator = _createForOfIteratorHelperLoose(alternateFormats.numberFormats()), _step; !(_step = _iterator()).done;) {\n      var alternateFormat = _step.value;\n      if (alternateFormat.leadingDigitsPatterns().length > 0) {\n        // There is only one leading digits pattern for alternate formats.\n        var leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0]);\n        if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {\n          // Leading digits don't match; try another one.\n          continue;\n        }\n      }\n      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat);\n      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n/**\r\n * Helper method to get the national-number part of a number, formatted without any national\r\n * prefix, and return it as a set of digit blocks that would be formatted together following\r\n * standard formatting rules.\r\n */\n\nfunction getNationalNumberGroups(metadata, number, formattingPattern) {\n  throw new Error('This part of code hasn\\'t been ported');\n  if (formattingPattern) {\n    // We format the NSN only, and split that according to the separator.\n    var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n    return util.formatNsnUsingPattern(nationalSignificantNumber, formattingPattern, 'RFC3966', metadata).split('-');\n  } // This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.\n\n  var rfc3966Format = formatNumber(number, 'RFC3966', metadata); // We remove the extension part from the formatted string before splitting it into different\n  // groups.\n\n  var endIndex = rfc3966Format.indexOf(';');\n  if (endIndex < 0) {\n    endIndex = rfc3966Format.length;\n  } // The country-code will have a '-' following it.\n\n  var startIndex = rfc3966Format.indexOf('-') + 1;\n  return rfc3966Format.slice(startIndex, endIndex).split('-');\n}\nfunction allNumberGroupsAreExactlyPresent(metadata, number, normalizedCandidate, formattedNumberGroups) {\n  throw new Error('This part of code hasn\\'t been ported');\n  var candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN); // Set this to the last group, skipping it if the number has an extension.\n\n  var candidateNumberGroupIndex = number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1; // First we check if the national significant number is formatted as a block.\n  // We use contains and not equals, since the national significant number may be present with\n  // a prefix such as a national number prefix, or the country code itself.\n\n  if (candidateGroups.length == 1 || candidateGroups[candidateNumberGroupIndex].contains(util.getNationalSignificantNumber(number))) {\n    return true;\n  } // Starting from the end, go through in reverse, excluding the first group, and check the\n  // candidate and number groups are the same.\n\n  var formattedNumberGroupIndex = formattedNumberGroups.length - 1;\n  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0) {\n    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex]) {\n      return false;\n    }\n    formattedNumberGroupIndex--;\n    candidateNumberGroupIndex--;\n  } // Now check the first group. There may be a national prefix at the start, so we only check\n  // that the candidate group ends with the formatted number group.\n\n  return candidateNumberGroupIndex >= 0 && endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]);\n}\nfunction allNumberGroupsRemainGrouped(metadata, number, normalizedCandidate, formattedNumberGroups) {\n  throw new Error('This part of code hasn\\'t been ported');\n  var fromIndex = 0;\n  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY) {\n    // First skip the country code if the normalized candidate contained it.\n    var countryCode = String(number.getCountryCode());\n    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length();\n  } // Check each group of consecutive digits are not broken into separate groupings in the\n  // {@code normalizedCandidate} string.\n\n  for (var i = 0; i < formattedNumberGroups.length; i++) {\n    // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\n    // doesn't contain the consecutive digits in formattedNumberGroups[i].\n    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex);\n    if (fromIndex < 0) {\n      return false;\n    } // Moves {@code fromIndex} forward.\n\n    fromIndex += formattedNumberGroups[i].length();\n    if (i == 0 && fromIndex < normalizedCandidate.length()) {\n      // We are at the position right after the NDC. We get the region used for formatting\n      // information based on the country code in the phone number, rather than the number itself,\n      // as we do not need to distinguish between different countries with the same country\n      // calling code and this is faster.\n      var region = util.getRegionCodeForCountryCode(number.getCountryCode());\n      if (util.getNddPrefixForRegion(region, true) != null && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\n        // This means there is no formatting symbol after the NDC. In this case, we only\n        // accept the number if there is no formatting symbol at all in the number, except\n        // for extensions. This is only important for countries with national prefixes.\n        var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n        return startsWith(normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length), nationalSignificantNumber);\n      }\n    }\n  } // The check here makes sure that we haven't mistakenly already used the extension to\n  // match the last group of the subscriber number. Note the extension cannot have\n  // formatting in-between digits.\n\n  return normalizedCandidate.slice(fromIndex).contains(number.getExtension());\n}","map":{"version":3,"sources":["../../source/findNumbers/Leniency.js"],"names":["isValidNumber","parseDigits","matchPhoneNumberStringAgainstPhoneNumber","Metadata","getCountryByCallingCode","chooseFormatForNumber","startsWith","endsWith","POSSIBLE","phoneNumber","candidate","metadata","VALID","isValid","containsOnlyValidXChars","STRICT_GROUPING","regExpCache","containsMoreThanOneSlashInNationalNumber","isNationalPrefixPresentIfRequired","checkNumberGroupingIsValid","allNumberGroupsRemainGrouped","EXACT_GROUPING","allNumberGroupsAreExactlyPresent","index","length","charAtIndex","charAt","charAtNextIndex","substring","ext","_metadata","__countryCallingCodeSource","selectNumberingPlan","countryCallingCode","phoneNumberRegion","country","nationalNumber","format","numberingPlan","formats","nationalPrefixFormattingRule","nationalPrefixIsOptionalWhenFormattingInNationalFormat","usesNationalPrefix","Boolean","nationalPrefix","firstSlashInBodyIndex","indexOf","secondSlashInBodyIndex","candidateHasCountryCode","slice","number","checkGroups","Error","normalizedCandidate","normalizeDigits","formattedNumberGroups","getNationalNumberGroups","alternateFormats","MetadataManager","getAlternateFormatsForCountry","getCountryCode","nationalSignificantNumber","util","getNationalSignificantNumber","alternateFormat","numberFormats","leadingDigitsPatterns","leadingDigitsRegExp","getPatternForRegExp","test","formattingPattern","formatNsnUsingPattern","split","rfc3966Format","formatNumber","endIndex","startIndex","candidateGroups","NON_DIGITS_PATTERN","candidateNumberGroupIndex","hasExtension","contains","formattedNumberGroupIndex","fromIndex","getCountryCodeSource","CountryCodeSource","FROM_DEFAULT_COUNTRY","countryCode","String","i","region","getRegionCodeForCountryCode","getNddPrefixForRegion","Character","isDigit","getExtension"],"mappings":"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","sourcesContent":["import isValidNumber from '../isValid.js'\r\nimport parseDigits from '../helpers/parseDigits.js'\r\nimport matchPhoneNumberStringAgainstPhoneNumber from './matchPhoneNumberStringAgainstPhoneNumber.js'\r\nimport Metadata from '../metadata.js'\r\nimport getCountryByCallingCode from '../helpers/getCountryByCallingCode.js'\r\nimport { chooseFormatForNumber } from '../format.js'\r\n\r\nimport {\r\n\tstartsWith,\r\n\tendsWith\r\n} from './util.js'\r\n\r\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\r\nexport default\r\n{\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n\t */\r\n\tPOSSIBLE(phoneNumber, candidate, metadata)\r\n\t{\r\n\t\treturn true\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\" and \"valid\".\r\n\t * Numbers written in national format must have their national-prefix\r\n\t * present if it is usually written for a number of this type.\r\n\t */\r\n\tVALID(phoneNumber, candidate, metadata)\r\n\t{\r\n\t\tif (\r\n\t\t\t!phoneNumber.isValid() ||\r\n\t\t\t!containsOnlyValidXChars(phoneNumber, candidate, metadata)\r\n\t\t)\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\t// Skipped for simplicity.\r\n\t\t// return isNationalPrefixPresentIfRequired(phoneNumber, metadata)\r\n\t\treturn true\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"valid\" and\r\n\t * are grouped in a possible way for this locale. For example, a US number written as\r\n\t * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n\t * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol in the national significant number\r\n\t * are also dropped at this level.\r\n\t *\r\n\t * Warning: This level might result in lower coverage especially for regions outside of\r\n\t * country code \"+1\". If you are not sure about which level to use,\r\n\t * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tSTRICT_GROUPING(phoneNumber, candidate, metadata, regExpCache)\r\n\t{\r\n\t\tif (\r\n\t\t\t!phoneNumber.isValid() ||\r\n\t\t\t!containsOnlyValidXChars(phoneNumber, candidate, metadata) ||\r\n\t\t\tcontainsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) ||\r\n\t\t\t!isNationalPrefixPresentIfRequired(phoneNumber, metadata)\r\n\t\t)\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tphoneNumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsRemainGrouped,\r\n\t\t\tregExpCache\r\n\t\t)\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"valid\" and are grouped in the same way\r\n\t * that we would have formatted it, or as a single block.\r\n\t * For example, a US number written as \"650 2530000\" is not accepted\r\n\t * at this leniency level, whereas \"650 253 0000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol are also dropped at this level.\r\n\t *\r\n\t * Warning: This level might result in lower coverage especially for regions outside of\r\n\t * country code \"+1\". If you are not sure about which level to use, email the discussion group\r\n\t * libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tEXACT_GROUPING(phoneNumber, candidate, metadata, regExpCache)\r\n\t{\r\n\t\tif (\r\n\t\t\t!phoneNumber.isValid() ||\r\n\t\t\t!containsOnlyValidXChars(phoneNumber, candidate, metadata) ||\r\n\t\t\tcontainsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) ||\r\n\t\t\t!isNationalPrefixPresentIfRequired(phoneNumber, metadata)\r\n\t\t)\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tphoneNumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsAreExactlyPresent,\r\n\t\t\tregExpCache\r\n\t\t)\r\n\t}\r\n}\r\n\r\nfunction containsOnlyValidXChars(phoneNumber, candidate, metadata)\r\n{\r\n\t// The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\r\n\t// national significant number or (2) an extension sign, in which case they always precede the\r\n\t// extension number. We assume a carrier code is more than 1 digit, so the first case has to\r\n\t// have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\r\n\t// or 'X'. We ignore the character if it appears as the last character of the string.\r\n\tfor (let index = 0; index < candidate.length - 1; index++)\r\n\t{\r\n\t\tconst charAtIndex = candidate.charAt(index)\r\n\r\n\t\tif (charAtIndex === 'x' || charAtIndex === 'X')\r\n\t\t{\r\n\t\t\tconst charAtNextIndex = candidate.charAt(index + 1)\r\n\r\n\t\t\tif (charAtNextIndex === 'x' || charAtNextIndex === 'X')\r\n\t\t\t{\r\n\t\t\t\t// This is the carrier code case, in which the 'X's always precede the national\r\n\t\t\t\t// significant number.\r\n\t\t\t\tindex++\r\n\t\t\t\tif (matchPhoneNumberStringAgainstPhoneNumber(candidate.substring(index), phoneNumber, metadata) !== 'NSN_MATCH')\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\t// This is the extension sign case, in which the 'x' or 'X' should always precede the\r\n\t\t\t\t// extension number.\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconst ext = parseDigits(candidate.substring(index))\r\n\t\t\t\tif (ext) {\r\n\t\t\t\t\tif (phoneNumber.ext !== ext)  {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (phoneNumber.ext) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunction isNationalPrefixPresentIfRequired(phoneNumber, _metadata)\r\n{\r\n\t// First, check how we deduced the country code. If it was written in international format, then\r\n\t// the national prefix is not required.\r\n\tif (phoneNumber.__countryCallingCodeSource !== 'FROM_DEFAULT_COUNTRY')\r\n\t{\r\n\t\treturn true\r\n\t}\r\n\r\n\tconst metadata = new Metadata(_metadata)\r\n\tmetadata.selectNumberingPlan(phoneNumber.countryCallingCode)\r\n\r\n\tconst phoneNumberRegion = phoneNumber.country || getCountryByCallingCode(phoneNumber.countryCallingCode, phoneNumber.nationalNumber, metadata)\r\n\r\n\t// Check if a national prefix should be present when formatting this number.\r\n\tconst nationalNumber = phoneNumber.nationalNumber\r\n\tconst format = chooseFormatForNumber(metadata.numberingPlan.formats(), nationalNumber)\r\n\r\n\t// To do this, we check that a national prefix formatting rule was present\r\n\t// and that it wasn't just the first-group symbol ($1) with punctuation.\r\n\tif (format.nationalPrefixFormattingRule())\r\n\t{\r\n\t\tif (metadata.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat())\r\n\t\t{\r\n\t\t\t// The national-prefix is optional in these cases, so we don't need to check if it was present.\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tif (!format.usesNationalPrefix())\r\n\t\t{\r\n\t\t\t// National Prefix not needed for this number.\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\treturn Boolean(phoneNumber.nationalPrefix)\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nexport function containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate)\r\n{\r\n\tconst firstSlashInBodyIndex = candidate.indexOf('/')\r\n\tif (firstSlashInBodyIndex < 0)\r\n\t{\r\n\t\t// No slashes, this is okay.\r\n\t\treturn false\r\n\t}\r\n\r\n\t// Now look for a second one.\r\n\tconst secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1)\r\n\tif (secondSlashInBodyIndex < 0)\r\n\t{\r\n\t\t// Only one slash, this is okay.\r\n\t\treturn false\r\n\t}\r\n\r\n\t// If the first slash is after the country calling code, this is permitted.\r\n\tconst candidateHasCountryCode =\r\n\t\t\tphoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITH_PLUS_SIGN' ||\r\n\t\t\tphoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITHOUT_PLUS_SIGN'\r\n\r\n\tif (candidateHasCountryCode && parseDigits(candidate.substring(0, firstSlashInBodyIndex)) === phoneNumber.countryCallingCode)\r\n\t{\r\n\t\t// Any more slashes and this is illegal.\r\n\t\treturn candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunction checkNumberGroupingIsValid(\r\n\tnumber,\r\n\tcandidate,\r\n\tmetadata,\r\n\tcheckGroups,\r\n\tregExpCache\r\n) {\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tconst normalizedCandidate = normalizeDigits(candidate, true /* keep non-digits */)\r\n\tlet formattedNumberGroups = getNationalNumberGroups(metadata, number, null)\r\n\tif (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\r\n\t\treturn true\r\n\t}\r\n\r\n\t// If this didn't pass, see if there are any alternate formats that match, and try them instead.\r\n\tconst alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode())\r\n\tconst nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n\r\n\tif (alternateFormats) {\r\n\t\tfor (const alternateFormat of alternateFormats.numberFormats()) {\r\n\t\t\tif (alternateFormat.leadingDigitsPatterns().length > 0) {\r\n\t\t\t\t// There is only one leading digits pattern for alternate formats.\r\n\t\t\t\tconst leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0])\r\n\t\t\t\tif (!leadingDigitsRegExp.test(nationalSignificantNumber)) {\r\n\t\t\t\t\t// Leading digits don't match; try another one.\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tformattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat)\r\n\t\t\tif (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn false\r\n}\r\n\r\n/**\r\n * Helper method to get the national-number part of a number, formatted without any national\r\n * prefix, and return it as a set of digit blocks that would be formatted together following\r\n * standard formatting rules.\r\n */\r\nfunction getNationalNumberGroups(\r\n\tmetadata,\r\n\tnumber,\r\n\tformattingPattern\r\n) {\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tif (formattingPattern) {\r\n\t\t// We format the NSN only, and split that according to the separator.\r\n\t\tconst nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n\t\treturn util.formatNsnUsingPattern(nationalSignificantNumber,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tformattingPattern, 'RFC3966', metadata).split('-')\r\n\t}\r\n\r\n\t// This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.\r\n\tconst rfc3966Format = formatNumber(number, 'RFC3966', metadata)\r\n\r\n\t// We remove the extension part from the formatted string before splitting it into different\r\n\t// groups.\r\n\tlet endIndex = rfc3966Format.indexOf(';')\r\n\tif (endIndex < 0) {\r\n\t\tendIndex = rfc3966Format.length\r\n\t}\r\n\r\n\t// The country-code will have a '-' following it.\r\n\tconst startIndex = rfc3966Format.indexOf('-') + 1\r\n\treturn rfc3966Format.slice(startIndex, endIndex).split('-')\r\n}\r\n\r\nfunction allNumberGroupsAreExactlyPresent\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tconst candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN)\r\n\r\n\t// Set this to the last group, skipping it if the number has an extension.\r\n\tlet candidateNumberGroupIndex =\r\n\t\t\tnumber.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1\r\n\r\n\t// First we check if the national significant number is formatted as a block.\r\n\t// We use contains and not equals, since the national significant number may be present with\r\n\t// a prefix such as a national number prefix, or the country code itself.\r\n\tif (candidateGroups.length == 1\r\n\t\t\t|| candidateGroups[candidateNumberGroupIndex].contains(\r\n\t\t\t\t\tutil.getNationalSignificantNumber(number)))\r\n\t{\r\n\t\treturn true\r\n\t}\r\n\r\n\t// Starting from the end, go through in reverse, excluding the first group, and check the\r\n\t// candidate and number groups are the same.\r\n\tlet formattedNumberGroupIndex = (formattedNumberGroups.length - 1)\r\n\twhile (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0)\r\n\t{\r\n\t\tif (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex])\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tformattedNumberGroupIndex--\r\n\t\tcandidateNumberGroupIndex--\r\n\t}\r\n\r\n\t// Now check the first group. There may be a national prefix at the start, so we only check\r\n\t// that the candidate group ends with the formatted number group.\r\n\treturn (candidateNumberGroupIndex >= 0\r\n\t\t\t&& endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]))\r\n}\r\n\r\n\r\nfunction allNumberGroupsRemainGrouped\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tlet fromIndex = 0\r\n\tif (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY)\r\n\t{\r\n\t\t// First skip the country code if the normalized candidate contained it.\r\n\t\tconst countryCode = String(number.getCountryCode())\r\n\t\tfromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length()\r\n\t}\r\n\r\n\t// Check each group of consecutive digits are not broken into separate groupings in the\r\n\t// {@code normalizedCandidate} string.\r\n\tfor (let i = 0; i < formattedNumberGroups.length; i++)\r\n\t{\r\n\t\t// Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\r\n\t\t// doesn't contain the consecutive digits in formattedNumberGroups[i].\r\n\t\tfromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex)\r\n\t\tif (fromIndex < 0) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// Moves {@code fromIndex} forward.\r\n\t\tfromIndex += formattedNumberGroups[i].length()\r\n\t\tif (i == 0 && fromIndex < normalizedCandidate.length())\r\n\t\t{\r\n\t\t\t// We are at the position right after the NDC. We get the region used for formatting\r\n\t\t\t// information based on the country code in the phone number, rather than the number itself,\r\n\t\t\t// as we do not need to distinguish between different countries with the same country\r\n\t\t\t// calling code and this is faster.\r\n\t\t\tconst region = util.getRegionCodeForCountryCode(number.getCountryCode())\r\n\t\t\tif (util.getNddPrefixForRegion(region, true) != null\r\n\t\t\t\t\t&& Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\r\n\t\t\t\t// This means there is no formatting symbol after the NDC. In this case, we only\r\n\t\t\t\t// accept the number if there is no formatting symbol at all in the number, except\r\n\t\t\t\t// for extensions. This is only important for countries with national prefixes.\r\n\t\t\t\tconst nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n\t\t\t\treturn startsWith\r\n\t\t\t\t(\r\n\t\t\t\t\tnormalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length),\r\n\t\t\t\t\t nationalSignificantNumber\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// The check here makes sure that we haven't mistakenly already used the extension to\r\n\t// match the last group of the subscriber number. Note the extension cannot have\r\n\t// formatting in-between digits.\r\n\treturn normalizedCandidate.slice(fromIndex).contains(number.getExtension())\r\n}"]},"metadata":{},"sourceType":"module"}