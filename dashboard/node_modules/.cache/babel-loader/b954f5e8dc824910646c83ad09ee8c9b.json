{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport { useRef, useState, useCallback, useEffect } from 'react';\nimport { AsYouType, getCountryCallingCode, parseDigits } from 'libphonenumber-js/core';\nimport getInternationalPhoneNumberPrefix from './helpers/getInternationalPhoneNumberPrefix.js';\n/**\r\n * Returns `[phoneDigits, setPhoneDigits]`.\r\n * \"Phone digits\" includes not only \"digits\" but also a `+` sign.\r\n */\n\nexport default function usePhoneDigits(_ref) {\n  var _this = this;\n  var value = _ref.value,\n    onChange = _ref.onChange,\n    country = _ref.country,\n    defaultCountry = _ref.defaultCountry,\n    international = _ref.international,\n    withCountryCallingCode = _ref.withCountryCallingCode,\n    useNationalFormatForDefaultCountryValue = _ref.useNationalFormatForDefaultCountryValue,\n    metadata = _ref.metadata;\n  var countryMismatchDetected = useRef();\n  var onCountryMismatch = function onCountryMismatch(value, country, actualCountry) {\n    console.error(\"[react-phone-number-input] Expected phone number \".concat(value, \" to correspond to country \").concat(country, \" but \").concat(actualCountry ? 'in reality it corresponds to country ' + actualCountry : 'it doesn\\'t', \".\"));\n    countryMismatchDetected.current = true;\n  };\n  var getInitialPhoneDigits = function getInitialPhoneDigits(options) {\n    return getPhoneDigitsForValue(value, country, international, withCountryCallingCode, defaultCountry, useNationalFormatForDefaultCountryValue, metadata, function () {\n      if (options && options.onCountryMismatch) {\n        options.onCountryMismatch();\n      }\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      onCountryMismatch.apply(_this, args);\n    });\n  }; // This is only used to detect `country` property change.\n\n  var _useState = useState(country),\n    _useState2 = _slicedToArray(_useState, 2),\n    prevCountry = _useState2[0],\n    setPrevCountry = _useState2[1]; // This is only used to detect `defaultCountry` property change.\n\n  var _useState3 = useState(defaultCountry),\n    _useState4 = _slicedToArray(_useState3, 2),\n    prevDefaultCountry = _useState4[0],\n    setPrevDefaultCountry = _useState4[1]; // `phoneDigits` is the `value` passed to the `<input/>`.\n\n  var _useState5 = useState(getInitialPhoneDigits()),\n    _useState6 = _slicedToArray(_useState5, 2),\n    phoneDigits = _useState6[0],\n    setPhoneDigits = _useState6[1]; // This is only used to detect `value` property changes.\n\n  var _useState7 = useState(value),\n    _useState8 = _slicedToArray(_useState7, 2),\n    valueForPhoneDigits = _useState8[0],\n    setValueForPhoneDigits = _useState8[1]; // Rerender hack.\n\n  var _useState9 = useState(),\n    _useState10 = _slicedToArray(_useState9, 2),\n    rerenderTrigger = _useState10[0],\n    setRerenderTrigger = _useState10[1];\n  var rerender = useCallback(function () {\n    return setRerenderTrigger({});\n  }, [setRerenderTrigger]);\n  function getValueForPhoneDigits(phoneDigits) {\n    // If the user hasn't input any digits then `value` is `undefined`.\n    if (!phoneDigits) {\n      return;\n    }\n    if (country && international && !withCountryCallingCode) {\n      phoneDigits = \"+\".concat(getCountryCallingCode(country, metadata)).concat(phoneDigits);\n    } // Return the E.164 phone number value.\n    //\n    // Even if no \"national (significant) number\" digits have been input,\n    // still return a non-`undefined` value.\n    // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/113\n    //\n    // For example, if the user has selected country `US` and entered `\"1\"`\n    // then that `\"1\"` is just a \"national prefix\" and no \"national (significant) number\"\n    // digits have been input yet. Still, return `\"+1\"` as `value` in such cases,\n    // because otherwise the app would think that the input is empty and mark it as such\n    // while in reality it isn't empty, which might be thought of as a \"bug\", or just\n    // a \"weird\" behavior.\n    //\n    // The only case when there's any input and `getNumberValue()` still returns `undefined`\n    // is when that input is `\"+\"`.\n    //\n\n    var asYouType = new AsYouType(country || defaultCountry, metadata);\n    asYouType.input(phoneDigits);\n    return asYouType.getNumberValue();\n  } // If `value` property has been changed externally\n  // then re-initialize the component.\n\n  useEffect(function () {\n    if (value !== valueForPhoneDigits) {\n      setValueForPhoneDigits(value);\n      setPhoneDigits(getInitialPhoneDigits());\n    }\n  }, [value]); // If the `country` has been changed then re-initialize the component.\n\n  useEffect(function () {\n    if (country !== prevCountry) {\n      setPrevCountry(country);\n      var _countryMismatchDetected;\n      var _phoneDigits = getInitialPhoneDigits({\n        onCountryMismatch: function onCountryMismatch() {\n          _countryMismatchDetected = true;\n        }\n      });\n      setPhoneDigits(_phoneDigits);\n      if (_countryMismatchDetected) {\n        setValueForPhoneDigits(getValueForPhoneDigits(_phoneDigits));\n      }\n    }\n  }, [country]); // If the `defaultCountry` has been changed then re-initialize the component.\n\n  useEffect(function () {\n    if (defaultCountry !== prevDefaultCountry) {\n      setPrevDefaultCountry(defaultCountry);\n      setPhoneDigits(getInitialPhoneDigits());\n    }\n  }, [defaultCountry]); // Update the `value` after `valueForPhoneDigits` has been updated.\n\n  useEffect(function () {\n    if (valueForPhoneDigits !== value) {\n      onChange(valueForPhoneDigits);\n    }\n  }, [valueForPhoneDigits]);\n  var onSetPhoneDigits = useCallback(function (phoneDigits) {\n    var value;\n    if (country) {\n      if (international && withCountryCallingCode) {\n        // The `<input/>` value must start with the country calling code.\n        var prefix = getInternationalPhoneNumberPrefix(country, metadata);\n        if (phoneDigits.indexOf(prefix) !== 0) {\n          // If a user tabs into a phone number input field\n          // that is `international` and `withCountryCallingCode`,\n          // and then starts inputting local phone number digits,\n          // the first digit would get \"swallowed\" if the fix below wasn't implemented.\n          // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\n          if (phoneDigits && phoneDigits[0] !== '+') {\n            phoneDigits = prefix + phoneDigits;\n          } else {\n            // // Reset phone digits if they don't start with the correct prefix.\n            // // Undo the `<input/>` value change if it doesn't.\n            if (countryMismatchDetected.current) {// In case of a `country`/`value` mismatch,\n              // if it performed an \"undo\" here, then\n              // it wouldn't let a user edit their phone number at all,\n              // so this special case at least allows phone number editing\n              // when `value` already doesn't match the `country`.\n            } else {\n              // If it simply did `phoneDigits = prefix` here,\n              // then it could have no effect when erasing phone number\n              // via Backspace, because `phoneDigits` in `state` wouldn't change\n              // as a result, because it was `prefix` and it became `prefix`,\n              // so the component wouldn't rerender, and the user would be able\n              // to erase the country calling code part, and that part is\n              // assumed to be non-eraseable. That's why the component is\n              // forcefully rerendered here.\n              setPhoneDigits(prefix);\n              setValueForPhoneDigits(undefined); // Force a re-render of the `<input/>` with previous `phoneDigits` value.\n\n              return rerender();\n            }\n          }\n        }\n      } else {\n        // Entering phone number either in \"national\" format\n        // when `country` has been specified, or in \"international\" format\n        // when `country` has been specified but `withCountryCallingCode` hasn't.\n        // Therefore, `+` is not allowed.\n        if (phoneDigits && phoneDigits[0] === '+') {\n          // Remove the `+`.\n          phoneDigits = phoneDigits.slice(1);\n        }\n      }\n    } else if (!defaultCountry) {\n      // Force a `+` in the beginning of a `value`\n      // when no `country` and `defaultCountry` have been specified.\n      if (phoneDigits && phoneDigits[0] !== '+') {\n        // Prepend a `+`.\n        phoneDigits = '+' + phoneDigits;\n      }\n    } // Convert `phoneDigits` to `value`.\n\n    if (phoneDigits) {\n      value = getValueForPhoneDigits(phoneDigits);\n    }\n    setPhoneDigits(phoneDigits);\n    setValueForPhoneDigits(value);\n  }, [country, international, withCountryCallingCode, defaultCountry, metadata, setPhoneDigits, setValueForPhoneDigits, rerender, countryMismatchDetected]);\n  return [phoneDigits, onSetPhoneDigits];\n}\n/**\r\n * Returns phone number input field value for a E.164 phone number `value`.\r\n * @param  {string} [value]\r\n * @param  {string} [country]\r\n * @param  {boolean} [international]\r\n * @param  {boolean} [withCountryCallingCode]\r\n * @param  {string} [defaultCountry]\r\n * @param  {boolean} [useNationalFormatForDefaultCountryValue]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\n\nfunction getPhoneDigitsForValue(value, country, international, withCountryCallingCode, defaultCountry, useNationalFormatForDefaultCountryValue, metadata, onCountryMismatch) {\n  if (country && international && withCountryCallingCode) {\n    var prefix = getInternationalPhoneNumberPrefix(country, metadata);\n    if (value) {\n      if (value.indexOf(prefix) !== 0) {\n        onCountryMismatch(value, country);\n      }\n      return value;\n    }\n    return prefix;\n  }\n  if (!value) {\n    return '';\n  }\n  if (!country && !defaultCountry) {\n    return value;\n  }\n  var asYouType = new AsYouType(undefined, metadata);\n  asYouType.input(value);\n  var phoneNumber = asYouType.getNumber();\n  if (phoneNumber) {\n    if (country) {\n      if (phoneNumber.country && phoneNumber.country !== country) {\n        onCountryMismatch(value, country, phoneNumber.country);\n      } else if (phoneNumber.countryCallingCode !== getCountryCallingCode(country, metadata)) {\n        onCountryMismatch(value, country);\n      }\n      if (international) {\n        return phoneNumber.nationalNumber;\n      }\n      return parseDigits(phoneNumber.formatNational());\n    } else {\n      // `phoneNumber.countryCallingCode` is compared here  instead of\n      // `phoneNumber.country`, because, for example, a person could have\n      // previously input a phone number (in \"national\" format) that isn't\n      // 100% valid for the `defaultCountry`, and if `phoneNumber.country`\n      // was compared, then it wouldn't match, and such phone number\n      // wouldn't be formatted as a \"national\" one, and instead would be\n      // formatted as an \"international\" one, confusing the user.\n      // Comparing `phoneNumber.countryCallingCode` works around such issues.\n      //\n      // Example: `defaultCountry=\"US\"` and the `<input/>` is empty.\n      // The user inputs: \"222 333 4444\", which gets formatted to \"(222) 333-4444\".\n      // The user then clicks \"Save\", the page is refreshed, and the user sees\n      // that the `<input/>` value is now \"+1 222 333 4444\" which confuses the user:\n      // the user expected the `<input/>` value to be \"(222) 333-4444\", same as it\n      // was when they've just typed it in. The cause of the issue is that \"222 333 4444\"\n      // is not a valid national number for US, and `phoneNumber.country` is compared\n      // instead of `phoneNumber.countryCallingCode`. After the `phoneNumber.country`\n      // comparison is replaced with `phoneNumber.countryCallingCode` one, the issue\n      // is no longer the case.\n      //\n      if (phoneNumber.countryCallingCode && phoneNumber.countryCallingCode === getCountryCallingCode(defaultCountry, metadata) && useNationalFormatForDefaultCountryValue) {\n        return parseDigits(phoneNumber.formatNational());\n      }\n      return value;\n    }\n  } else {\n    return '';\n  }\n}","map":{"version":3,"sources":["../source/usePhoneDigits.js"],"names":["useRef","useState","useCallback","useEffect","AsYouType","getCountryCallingCode","parseDigits","getInternationalPhoneNumberPrefix","usePhoneDigits","value","onChange","country","defaultCountry","international","withCountryCallingCode","useNationalFormatForDefaultCountryValue","metadata","countryMismatchDetected","onCountryMismatch","actualCountry","console","error","current","getInitialPhoneDigits","options","getPhoneDigitsForValue","args","apply","prevCountry","setPrevCountry","prevDefaultCountry","setPrevDefaultCountry","phoneDigits","setPhoneDigits","valueForPhoneDigits","setValueForPhoneDigits","rerenderTrigger","setRerenderTrigger","rerender","getValueForPhoneDigits","asYouType","input","getNumberValue","onSetPhoneDigits","prefix","indexOf","undefined","slice","phoneNumber","getNumber","countryCallingCode","nationalNumber","formatNational"],"mappings":"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","sourcesContent":["import { useRef, useState, useCallback, useEffect } from 'react'\r\nimport { AsYouType, getCountryCallingCode, parseDigits } from 'libphonenumber-js/core'\r\n\r\nimport getInternationalPhoneNumberPrefix from './helpers/getInternationalPhoneNumberPrefix.js'\r\n\r\n/**\r\n * Returns `[phoneDigits, setPhoneDigits]`.\r\n * \"Phone digits\" includes not only \"digits\" but also a `+` sign.\r\n */\r\nexport default function usePhoneDigits({\r\n\tvalue,\r\n\tonChange,\r\n\tcountry,\r\n\tdefaultCountry,\r\n\tinternational,\r\n\twithCountryCallingCode,\r\n\tuseNationalFormatForDefaultCountryValue,\r\n\tmetadata\r\n}) {\r\n\tconst countryMismatchDetected = useRef()\r\n\tconst onCountryMismatch = (value, country, actualCountry) => {\r\n\t\tconsole.error(`[react-phone-number-input] Expected phone number ${value} to correspond to country ${country} but ${actualCountry ? 'in reality it corresponds to country ' + actualCountry : 'it doesn\\'t'}.`)\r\n\t\tcountryMismatchDetected.current = true\r\n\t}\r\n\r\n\tconst getInitialPhoneDigits = (options) => {\r\n\t\treturn getPhoneDigitsForValue(\r\n\t\t\tvalue,\r\n\t\t\tcountry,\r\n\t\t\tinternational,\r\n\t\t\twithCountryCallingCode,\r\n\t\t\tdefaultCountry,\r\n\t\t\tuseNationalFormatForDefaultCountryValue,\r\n\t\t\tmetadata,\r\n\t\t\t(...args) => {\r\n\t\t\t\tif (options && options.onCountryMismatch) {\r\n\t\t\t\t\toptions.onCountryMismatch()\r\n\t\t\t\t}\r\n\t\t\t\tonCountryMismatch.apply(this, args)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\r\n\t// This is only used to detect `country` property change.\r\n\tconst [prevCountry, setPrevCountry] = useState(country)\r\n\t// This is only used to detect `defaultCountry` property change.\r\n\tconst [prevDefaultCountry, setPrevDefaultCountry] = useState(defaultCountry)\r\n\t// `phoneDigits` is the `value` passed to the `<input/>`.\r\n\tconst [phoneDigits, setPhoneDigits] = useState(getInitialPhoneDigits())\r\n\t// This is only used to detect `value` property changes.\r\n\tconst [valueForPhoneDigits, setValueForPhoneDigits] = useState(value)\r\n\r\n\t// Rerender hack.\r\n\tconst [rerenderTrigger, setRerenderTrigger] = useState()\r\n\tconst rerender = useCallback(() => setRerenderTrigger({}), [setRerenderTrigger])\r\n\r\n\tfunction getValueForPhoneDigits(phoneDigits) {\r\n\t\t// If the user hasn't input any digits then `value` is `undefined`.\r\n\t\tif (!phoneDigits) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif (country && international && !withCountryCallingCode) {\r\n\t\t\tphoneDigits = `+${getCountryCallingCode(country, metadata)}${phoneDigits}`\r\n\t\t}\r\n\t\t// Return the E.164 phone number value.\r\n\t\t//\r\n\t\t// Even if no \"national (significant) number\" digits have been input,\r\n\t\t// still return a non-`undefined` value.\r\n\t\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/113\r\n\t\t//\r\n\t\t// For example, if the user has selected country `US` and entered `\"1\"`\r\n\t\t// then that `\"1\"` is just a \"national prefix\" and no \"national (significant) number\"\r\n\t\t// digits have been input yet. Still, return `\"+1\"` as `value` in such cases,\r\n\t\t// because otherwise the app would think that the input is empty and mark it as such\r\n\t\t// while in reality it isn't empty, which might be thought of as a \"bug\", or just\r\n\t\t// a \"weird\" behavior.\r\n\t\t//\r\n\t\t// The only case when there's any input and `getNumberValue()` still returns `undefined`\r\n\t\t// is when that input is `\"+\"`.\r\n\t\t//\r\n\t\tconst asYouType = new AsYouType(country || defaultCountry, metadata)\r\n\t\tasYouType.input(phoneDigits)\r\n\t\treturn asYouType.getNumberValue()\r\n\t}\r\n\r\n\t// If `value` property has been changed externally\r\n\t// then re-initialize the component.\r\n\tuseEffect(() => {\r\n\t\tif (value !== valueForPhoneDigits) {\r\n\t\t\tsetValueForPhoneDigits(value)\r\n\t\t\tsetPhoneDigits(getInitialPhoneDigits())\r\n\t\t}\r\n\t}, [value])\r\n\r\n\t// If the `country` has been changed then re-initialize the component.\r\n\tuseEffect(() => {\r\n\t\tif (country !== prevCountry) {\r\n\t\t\tsetPrevCountry(country)\r\n\t\t\tlet countryMismatchDetected\r\n\t\t\tconst phoneDigits = getInitialPhoneDigits({\r\n\t\t\t\tonCountryMismatch() {\r\n\t\t\t\t\tcountryMismatchDetected = true\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tsetPhoneDigits(phoneDigits)\r\n\t\t\tif (countryMismatchDetected) {\r\n\t\t\t\tsetValueForPhoneDigits(getValueForPhoneDigits(phoneDigits))\r\n\t\t\t}\r\n\t\t}\r\n\t}, [country])\r\n\r\n\t// If the `defaultCountry` has been changed then re-initialize the component.\r\n\tuseEffect(() => {\r\n\t\tif (defaultCountry !== prevDefaultCountry) {\r\n\t\t\tsetPrevDefaultCountry(defaultCountry)\r\n\t\t\tsetPhoneDigits(getInitialPhoneDigits())\r\n\t\t}\r\n\t}, [defaultCountry])\r\n\r\n\t// Update the `value` after `valueForPhoneDigits` has been updated.\r\n\tuseEffect(() => {\r\n\t\tif (valueForPhoneDigits !== value) {\r\n\t\t\tonChange(valueForPhoneDigits)\r\n\t\t}\r\n\t}, [valueForPhoneDigits])\r\n\r\n\tconst onSetPhoneDigits = useCallback((phoneDigits) => {\r\n\t\tlet value\r\n\t\tif (country) {\r\n\t\t\tif (international && withCountryCallingCode) {\r\n\t\t\t\t// The `<input/>` value must start with the country calling code.\r\n\t\t\t\tconst prefix = getInternationalPhoneNumberPrefix(country, metadata)\r\n\t\t\t\tif (phoneDigits.indexOf(prefix) !== 0) {\r\n\t\t\t\t\t// If a user tabs into a phone number input field\r\n\t\t\t\t\t// that is `international` and `withCountryCallingCode`,\r\n\t\t\t\t\t// and then starts inputting local phone number digits,\r\n\t\t\t\t\t// the first digit would get \"swallowed\" if the fix below wasn't implemented.\r\n\t\t\t\t\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\r\n\t\t\t\t\tif (phoneDigits && phoneDigits[0] !== '+') {\r\n\t\t\t\t\t\tphoneDigits = prefix + phoneDigits\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// // Reset phone digits if they don't start with the correct prefix.\r\n\t\t\t\t\t\t// // Undo the `<input/>` value change if it doesn't.\r\n\t\t\t\t\t\tif (countryMismatchDetected.current) {\r\n\t\t\t\t\t\t\t// In case of a `country`/`value` mismatch,\r\n\t\t\t\t\t\t\t// if it performed an \"undo\" here, then\r\n\t\t\t\t\t\t\t// it wouldn't let a user edit their phone number at all,\r\n\t\t\t\t\t\t\t// so this special case at least allows phone number editing\r\n\t\t\t\t\t\t\t// when `value` already doesn't match the `country`.\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// If it simply did `phoneDigits = prefix` here,\r\n\t\t\t\t\t\t\t// then it could have no effect when erasing phone number\r\n\t\t\t\t\t\t\t// via Backspace, because `phoneDigits` in `state` wouldn't change\r\n\t\t\t\t\t\t\t// as a result, because it was `prefix` and it became `prefix`,\r\n\t\t\t\t\t\t\t// so the component wouldn't rerender, and the user would be able\r\n\t\t\t\t\t\t\t// to erase the country calling code part, and that part is\r\n\t\t\t\t\t\t\t// assumed to be non-eraseable. That's why the component is\r\n\t\t\t\t\t\t\t// forcefully rerendered here.\r\n\t\t\t\t\t\t\tsetPhoneDigits(prefix)\r\n\t\t\t\t\t\t\tsetValueForPhoneDigits(undefined)\r\n\t\t\t\t\t\t\t// Force a re-render of the `<input/>` with previous `phoneDigits` value.\r\n\t\t\t\t\t\t\treturn rerender()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Entering phone number either in \"national\" format\r\n\t\t\t\t// when `country` has been specified, or in \"international\" format\r\n\t\t\t\t// when `country` has been specified but `withCountryCallingCode` hasn't.\r\n\t\t\t\t// Therefore, `+` is not allowed.\r\n\t\t\t\tif (phoneDigits && phoneDigits[0] === '+') {\r\n\t\t\t\t\t// Remove the `+`.\r\n\t\t\t\t\tphoneDigits = phoneDigits.slice(1)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (!defaultCountry) {\r\n\t\t\t// Force a `+` in the beginning of a `value`\r\n\t\t\t// when no `country` and `defaultCountry` have been specified.\r\n\t\t\tif (phoneDigits && phoneDigits[0] !== '+') {\r\n\t\t\t\t// Prepend a `+`.\r\n\t\t\t\tphoneDigits = '+' + phoneDigits\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Convert `phoneDigits` to `value`.\r\n\t\tif (phoneDigits) {\r\n\t\t\tvalue = getValueForPhoneDigits(phoneDigits)\r\n\t\t}\r\n\t\tsetPhoneDigits(phoneDigits)\r\n\t\tsetValueForPhoneDigits(value)\r\n\t}, [\r\n\t\tcountry,\r\n\t\tinternational,\r\n\t\twithCountryCallingCode,\r\n\t\tdefaultCountry,\r\n\t\tmetadata,\r\n\t\tsetPhoneDigits,\r\n\t\tsetValueForPhoneDigits,\r\n\t\trerender,\r\n\t\tcountryMismatchDetected\r\n\t])\r\n\r\n\treturn [\r\n\t\tphoneDigits,\r\n\t\tonSetPhoneDigits\r\n\t]\r\n}\r\n\r\n/**\r\n * Returns phone number input field value for a E.164 phone number `value`.\r\n * @param  {string} [value]\r\n * @param  {string} [country]\r\n * @param  {boolean} [international]\r\n * @param  {boolean} [withCountryCallingCode]\r\n * @param  {string} [defaultCountry]\r\n * @param  {boolean} [useNationalFormatForDefaultCountryValue]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\r\nfunction getPhoneDigitsForValue(\r\n\tvalue,\r\n\tcountry,\r\n\tinternational,\r\n\twithCountryCallingCode,\r\n\tdefaultCountry,\r\n\tuseNationalFormatForDefaultCountryValue,\r\n\tmetadata,\r\n\tonCountryMismatch\r\n) {\r\n\tif (country && international && withCountryCallingCode) {\r\n\t\tconst prefix = getInternationalPhoneNumberPrefix(country, metadata)\r\n\t\tif (value) {\r\n\t\t\tif (value.indexOf(prefix) !== 0) {\r\n\t\t\t\tonCountryMismatch(value, country)\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t\treturn prefix\r\n\t}\r\n\tif (!value) {\r\n\t\treturn ''\r\n\t}\r\n\tif (!country && !defaultCountry) {\r\n\t\treturn value\r\n\t}\r\n\tconst asYouType = new AsYouType(undefined, metadata)\r\n\tasYouType.input(value)\r\n\tconst phoneNumber = asYouType.getNumber()\r\n\tif (phoneNumber) {\r\n\t\tif (country) {\r\n\t\t\tif (phoneNumber.country && phoneNumber.country !== country) {\r\n\t\t\t\tonCountryMismatch(value, country, phoneNumber.country)\r\n\t\t\t} else if (phoneNumber.countryCallingCode !== getCountryCallingCode(country, metadata)) {\r\n\t\t\t\tonCountryMismatch(value, country)\r\n\t\t\t}\r\n\t\t\tif (international) {\r\n\t\t\t\treturn phoneNumber.nationalNumber\r\n\t\t\t}\r\n\t\t\treturn parseDigits(phoneNumber.formatNational())\r\n\t\t} else {\r\n\t\t\t// `phoneNumber.countryCallingCode` is compared here  instead of\r\n\t\t\t// `phoneNumber.country`, because, for example, a person could have\r\n\t\t\t// previously input a phone number (in \"national\" format) that isn't\r\n\t\t\t// 100% valid for the `defaultCountry`, and if `phoneNumber.country`\r\n\t\t\t// was compared, then it wouldn't match, and such phone number\r\n\t\t\t// wouldn't be formatted as a \"national\" one, and instead would be\r\n\t\t\t// formatted as an \"international\" one, confusing the user.\r\n\t\t\t// Comparing `phoneNumber.countryCallingCode` works around such issues.\r\n\t\t\t//\r\n\t\t\t// Example: `defaultCountry=\"US\"` and the `<input/>` is empty.\r\n\t\t\t// The user inputs: \"222 333 4444\", which gets formatted to \"(222) 333-4444\".\r\n\t\t\t// The user then clicks \"Save\", the page is refreshed, and the user sees\r\n\t\t\t// that the `<input/>` value is now \"+1 222 333 4444\" which confuses the user:\r\n\t\t\t// the user expected the `<input/>` value to be \"(222) 333-4444\", same as it\r\n\t\t\t// was when they've just typed it in. The cause of the issue is that \"222 333 4444\"\r\n\t\t\t// is not a valid national number for US, and `phoneNumber.country` is compared\r\n\t\t\t// instead of `phoneNumber.countryCallingCode`. After the `phoneNumber.country`\r\n\t\t\t// comparison is replaced with `phoneNumber.countryCallingCode` one, the issue\r\n\t\t\t// is no longer the case.\r\n\t\t\t//\r\n\t\t\tif (phoneNumber.countryCallingCode && phoneNumber.countryCallingCode === getCountryCallingCode(defaultCountry, metadata) && useNationalFormatForDefaultCountryValue) {\r\n\t\t\t\treturn parseDigits(phoneNumber.formatNational())\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t} else {\r\n\t\treturn ''\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}