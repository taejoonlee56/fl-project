{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Socket = void 0;\n\nvar events_1 = require(\"events\");\n\nvar debug_1 = require(\"debug\");\n\nvar timers_1 = require(\"timers\");\n\nvar debug = (0, debug_1.default)(\"engine:socket\");\n\nvar Socket = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Socket, _events_1$EventEmitte);\n\n  var _super = _createSuper(Socket);\n\n  /**\n   * Client class (abstract).\n   *\n   * @api private\n   */\n  function Socket(id, server, transport, req, protocol) {\n    var _this;\n\n    _classCallCheck(this, Socket);\n\n    _this = _super.call(this);\n    _this.id = id;\n    _this.server = server;\n    _this.upgrading = false;\n    _this.upgraded = false;\n    _this.readyState = \"opening\";\n    _this.writeBuffer = [];\n    _this.packetsFn = [];\n    _this.sentCallbackFn = [];\n    _this.cleanupFn = [];\n    _this.request = req;\n    _this.protocol = protocol; // Cache IP since it might not be in the req later\n\n    if (req.websocket && req.websocket._socket) {\n      _this.remoteAddress = req.websocket._socket.remoteAddress;\n    } else {\n      _this.remoteAddress = req.connection.remoteAddress;\n    }\n\n    _this.checkIntervalTimer = null;\n    _this.upgradeTimeoutTimer = null;\n    _this.pingTimeoutTimer = null;\n    _this.pingIntervalTimer = null;\n\n    _this.setTransport(transport);\n\n    _this.onOpen();\n\n    return _this;\n  }\n\n  _createClass(Socket, [{\n    key: \"readyState\",\n    get: function get() {\n      return this._readyState;\n    },\n    set: function set(state) {\n      debug(\"readyState updated from %s to %s\", this._readyState, state);\n      this._readyState = state;\n    }\n    /**\n     * Called upon transport considered open.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"onOpen\",\n    value: function onOpen() {\n      this.readyState = \"open\"; // sends an `open` packet\n\n      this.transport.sid = this.id;\n      this.sendPacket(\"open\", JSON.stringify({\n        sid: this.id,\n        upgrades: this.getAvailableUpgrades(),\n        pingInterval: this.server.opts.pingInterval,\n        pingTimeout: this.server.opts.pingTimeout,\n        maxPayload: this.server.opts.maxHttpBufferSize\n      }));\n\n      if (this.server.opts.initialPacket) {\n        this.sendPacket(\"message\", this.server.opts.initialPacket);\n      }\n\n      this.emit(\"open\");\n\n      if (this.protocol === 3) {\n        // in protocol v3, the client sends a ping, and the server answers with a pong\n        this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n      } else {\n        // in protocol v4, the server sends a ping, and the client answers with a pong\n        this.schedulePing();\n      }\n    }\n    /**\n     * Called upon transport packet.\n     *\n     * @param {Object} packet\n     * @api private\n     */\n\n  }, {\n    key: \"onPacket\",\n    value: function onPacket(packet) {\n      if (\"open\" !== this.readyState) {\n        return debug(\"packet received with closed socket\");\n      } // export packet event\n\n\n      debug(\"received packet \".concat(packet.type));\n      this.emit(\"packet\", packet); // Reset ping timeout on any packet, incoming data is a good sign of\n      // other side's liveness\n\n      this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n\n      switch (packet.type) {\n        case \"ping\":\n          if (this.transport.protocol !== 3) {\n            this.onError(\"invalid heartbeat direction\");\n            return;\n          }\n\n          debug(\"got ping\");\n          this.sendPacket(\"pong\");\n          this.emit(\"heartbeat\");\n          break;\n\n        case \"pong\":\n          if (this.transport.protocol === 3) {\n            this.onError(\"invalid heartbeat direction\");\n            return;\n          }\n\n          debug(\"got pong\");\n          this.pingIntervalTimer.refresh();\n          this.emit(\"heartbeat\");\n          break;\n\n        case \"error\":\n          this.onClose(\"parse error\");\n          break;\n\n        case \"message\":\n          this.emit(\"data\", packet.data);\n          this.emit(\"message\", packet.data);\n          break;\n      }\n    }\n    /**\n     * Called upon transport error.\n     *\n     * @param {Error} error object\n     * @api private\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(err) {\n      debug(\"transport error\");\n      this.onClose(\"transport error\", err);\n    }\n    /**\n     * Pings client every `this.pingInterval` and expects response\n     * within `this.pingTimeout` or closes connection.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"schedulePing\",\n    value: function schedulePing() {\n      var _this2 = this;\n\n      this.pingIntervalTimer = (0, timers_1.setTimeout)(function () {\n        debug(\"writing ping packet - expecting pong within %sms\", _this2.server.opts.pingTimeout);\n\n        _this2.sendPacket(\"ping\");\n\n        _this2.resetPingTimeout(_this2.server.opts.pingTimeout);\n      }, this.server.opts.pingInterval);\n    }\n    /**\n     * Resets ping timeout.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"resetPingTimeout\",\n    value: function resetPingTimeout(timeout) {\n      var _this3 = this;\n\n      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n      this.pingTimeoutTimer = (0, timers_1.setTimeout)(function () {\n        if (_this3.readyState === \"closed\") return;\n\n        _this3.onClose(\"ping timeout\");\n      }, timeout);\n    }\n    /**\n     * Attaches handlers for the given transport.\n     *\n     * @param {Transport} transport\n     * @api private\n     */\n\n  }, {\n    key: \"setTransport\",\n    value: function setTransport(transport) {\n      var onError = this.onError.bind(this);\n      var onPacket = this.onPacket.bind(this);\n      var flush = this.flush.bind(this);\n      var onClose = this.onClose.bind(this, \"transport close\");\n      this.transport = transport;\n      this.transport.once(\"error\", onError);\n      this.transport.on(\"packet\", onPacket);\n      this.transport.on(\"drain\", flush);\n      this.transport.once(\"close\", onClose); // this function will manage packet events (also message callbacks)\n\n      this.setupSendCallback();\n      this.cleanupFn.push(function () {\n        transport.removeListener(\"error\", onError);\n        transport.removeListener(\"packet\", onPacket);\n        transport.removeListener(\"drain\", flush);\n        transport.removeListener(\"close\", onClose);\n      });\n    }\n    /**\n     * Upgrades socket to the given transport\n     *\n     * @param {Transport} transport\n     * @api private\n     */\n\n  }, {\n    key: \"maybeUpgrade\",\n    value: function maybeUpgrade(transport) {\n      var _this4 = this;\n\n      debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n      this.upgrading = true; // set transport upgrade timer\n\n      this.upgradeTimeoutTimer = (0, timers_1.setTimeout)(function () {\n        debug(\"client did not complete upgrade - closing transport\");\n        cleanup();\n\n        if (\"open\" === transport.readyState) {\n          transport.close();\n        }\n      }, this.server.opts.upgradeTimeout);\n\n      var onPacket = function onPacket(packet) {\n        if (\"ping\" === packet.type && \"probe\" === packet.data) {\n          debug(\"got probe ping packet, sending pong\");\n          transport.send([{\n            type: \"pong\",\n            data: \"probe\"\n          }]);\n\n          _this4.emit(\"upgrading\", transport);\n\n          clearInterval(_this4.checkIntervalTimer);\n          _this4.checkIntervalTimer = setInterval(check, 100);\n        } else if (\"upgrade\" === packet.type && _this4.readyState !== \"closed\") {\n          debug(\"got upgrade packet - upgrading\");\n          cleanup();\n\n          _this4.transport.discard();\n\n          _this4.upgraded = true;\n\n          _this4.clearTransport();\n\n          _this4.setTransport(transport);\n\n          _this4.emit(\"upgrade\", transport);\n\n          _this4.flush();\n\n          if (_this4.readyState === \"closing\") {\n            transport.close(function () {\n              _this4.onClose(\"forced close\");\n            });\n          }\n        } else {\n          cleanup();\n          transport.close();\n        }\n      }; // we force a polling cycle to ensure a fast upgrade\n\n\n      var check = function check() {\n        if (\"polling\" === _this4.transport.name && _this4.transport.writable) {\n          debug(\"writing a noop packet to polling for fast upgrade\");\n\n          _this4.transport.send([{\n            type: \"noop\"\n          }]);\n        }\n      };\n\n      var cleanup = function cleanup() {\n        _this4.upgrading = false;\n        clearInterval(_this4.checkIntervalTimer);\n        _this4.checkIntervalTimer = null;\n        (0, timers_1.clearTimeout)(_this4.upgradeTimeoutTimer);\n        _this4.upgradeTimeoutTimer = null;\n        transport.removeListener(\"packet\", onPacket);\n        transport.removeListener(\"close\", onTransportClose);\n        transport.removeListener(\"error\", onError);\n\n        _this4.removeListener(\"close\", onClose);\n      };\n\n      var onError = function onError(err) {\n        debug(\"client did not complete upgrade - %s\", err);\n        cleanup();\n        transport.close();\n        transport = null;\n      };\n\n      var onTransportClose = function onTransportClose() {\n        onError(\"transport closed\");\n      };\n\n      var onClose = function onClose() {\n        onError(\"socket closed\");\n      };\n\n      transport.on(\"packet\", onPacket);\n      transport.once(\"close\", onTransportClose);\n      transport.once(\"error\", onError);\n      this.once(\"close\", onClose);\n    }\n    /**\n     * Clears listeners and timers associated with current transport.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"clearTransport\",\n    value: function clearTransport() {\n      var cleanup;\n      var toCleanUp = this.cleanupFn.length;\n\n      for (var i = 0; i < toCleanUp; i++) {\n        cleanup = this.cleanupFn.shift();\n        cleanup();\n      } // silence further transport errors and prevent uncaught exceptions\n\n\n      this.transport.on(\"error\", function () {\n        debug(\"error triggered by discarded transport\");\n      }); // ensure transport won't stay open\n\n      this.transport.close();\n      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n    }\n    /**\n     * Called upon transport considered closed.\n     * Possible reasons: `ping timeout`, `client error`, `parse error`,\n     * `transport error`, `server close`, `transport close`\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose(reason, description) {\n      var _this5 = this;\n\n      if (\"closed\" !== this.readyState) {\n        this.readyState = \"closed\"; // clear timers\n\n        (0, timers_1.clearTimeout)(this.pingIntervalTimer);\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n        clearInterval(this.checkIntervalTimer);\n        this.checkIntervalTimer = null;\n        (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer); // clean writeBuffer in next tick, so developers can still\n        // grab the writeBuffer on 'close' event\n\n        process.nextTick(function () {\n          _this5.writeBuffer = [];\n        });\n        this.packetsFn = [];\n        this.sentCallbackFn = [];\n        this.clearTransport();\n        this.emit(\"close\", reason, description);\n      }\n    }\n    /**\n     * Setup and manage send callback\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"setupSendCallback\",\n    value: function setupSendCallback() {\n      var _this6 = this;\n\n      // the message was sent successfully, execute the callback\n      var onDrain = function onDrain() {\n        if (_this6.sentCallbackFn.length > 0) {\n          var seqFn = _this6.sentCallbackFn.splice(0, 1)[0];\n\n          if (\"function\" === typeof seqFn) {\n            debug(\"executing send callback\");\n            seqFn(_this6.transport);\n          } else if (Array.isArray(seqFn)) {\n            debug(\"executing batch send callback\");\n            var l = seqFn.length;\n            var i = 0;\n\n            for (; i < l; i++) {\n              if (\"function\" === typeof seqFn[i]) {\n                seqFn[i](_this6.transport);\n              }\n            }\n          }\n        }\n      };\n\n      this.transport.on(\"drain\", onDrain);\n      this.cleanupFn.push(function () {\n        _this6.transport.removeListener(\"drain\", onDrain);\n      });\n    }\n    /**\n     * Sends a message packet.\n     *\n     * @param {Object} data\n     * @param {Object} options\n     * @param {Function} callback\n     * @return {Socket} for chaining\n     * @api public\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(data, options, callback) {\n      this.sendPacket(\"message\", data, options, callback);\n      return this;\n    }\n  }, {\n    key: \"write\",\n    value: function write(data, options, callback) {\n      this.sendPacket(\"message\", data, options, callback);\n      return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type - packet type\n     * @param {String} data\n     * @param {Object} options\n     * @param {Function} callback\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"sendPacket\",\n    value: function sendPacket(type, data, options, callback) {\n      if (\"function\" === typeof options) {\n        callback = options;\n        options = null;\n      }\n\n      options = options || {};\n      options.compress = false !== options.compress;\n\n      if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n        debug('sending packet \"%s\" (%s)', type, data);\n        var packet = {\n          type: type,\n          options: options\n        };\n        if (data) packet.data = data; // exports packetCreate event\n\n        this.emit(\"packetCreate\", packet);\n        this.writeBuffer.push(packet); // add send callback to object, if defined\n\n        if (callback) this.packetsFn.push(callback);\n        this.flush();\n      }\n    }\n    /**\n     * Attempts to flush the packets buffer.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (\"closed\" !== this.readyState && this.transport.writable && this.writeBuffer.length) {\n        debug(\"flushing buffer to transport\");\n        this.emit(\"flush\", this.writeBuffer);\n        this.server.emit(\"flush\", this, this.writeBuffer);\n        var wbuf = this.writeBuffer;\n        this.writeBuffer = [];\n\n        if (!this.transport.supportsFraming) {\n          this.sentCallbackFn.push(this.packetsFn);\n        } else {\n          this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n        }\n\n        this.packetsFn = [];\n        this.transport.send(wbuf);\n        this.emit(\"drain\");\n        this.server.emit(\"drain\", this);\n      }\n    }\n    /**\n     * Get available upgrades for this socket.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"getAvailableUpgrades\",\n    value: function getAvailableUpgrades() {\n      var availableUpgrades = [];\n      var allUpgrades = this.server.upgrades(this.transport.name);\n      var i = 0;\n      var l = allUpgrades.length;\n\n      for (; i < l; ++i) {\n        var upg = allUpgrades[i];\n\n        if (this.server.opts.transports.indexOf(upg) !== -1) {\n          availableUpgrades.push(upg);\n        }\n      }\n\n      return availableUpgrades;\n    }\n    /**\n     * Closes the socket and underlying transport.\n     *\n     * @param {Boolean} discard - optional, discard the transport\n     * @return {Socket} for chaining\n     * @api public\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(discard) {\n      if (\"open\" !== this.readyState) return;\n      this.readyState = \"closing\";\n\n      if (this.writeBuffer.length) {\n        this.once(\"drain\", this.closeTransport.bind(this, discard));\n        return;\n      }\n\n      this.closeTransport(discard);\n    }\n    /**\n     * Closes the underlying transport.\n     *\n     * @param {Boolean} discard\n     * @api private\n     */\n\n  }, {\n    key: \"closeTransport\",\n    value: function closeTransport(discard) {\n      if (discard) this.transport.discard();\n      this.transport.close(this.onClose.bind(this, \"forced close\"));\n    }\n  }]);\n\n  return Socket;\n}(events_1.EventEmitter);\n\nexports.Socket = Socket;","map":{"version":3,"sources":["/home/tj/fl-carla/node_modules/engine.io/build/socket.js"],"names":["Object","defineProperty","exports","value","Socket","events_1","require","debug_1","timers_1","debug","default","id","server","transport","req","protocol","upgrading","upgraded","readyState","writeBuffer","packetsFn","sentCallbackFn","cleanupFn","request","websocket","_socket","remoteAddress","connection","checkIntervalTimer","upgradeTimeoutTimer","pingTimeoutTimer","pingIntervalTimer","setTransport","onOpen","_readyState","state","sid","sendPacket","JSON","stringify","upgrades","getAvailableUpgrades","pingInterval","opts","pingTimeout","maxPayload","maxHttpBufferSize","initialPacket","emit","resetPingTimeout","schedulePing","packet","type","onError","refresh","onClose","data","err","setTimeout","timeout","clearTimeout","bind","onPacket","flush","once","on","setupSendCallback","push","removeListener","name","cleanup","close","upgradeTimeout","send","clearInterval","setInterval","check","discard","clearTransport","writable","onTransportClose","toCleanUp","length","i","shift","reason","description","process","nextTick","onDrain","seqFn","splice","Array","isArray","l","options","callback","compress","wbuf","supportsFraming","apply","availableUpgrades","allUpgrades","upg","transports","indexOf","closeTransport","EventEmitter"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = void 0;\nconst events_1 = require(\"events\");\nconst debug_1 = require(\"debug\");\nconst timers_1 = require(\"timers\");\nconst debug = (0, debug_1.default)(\"engine:socket\");\nclass Socket extends events_1.EventEmitter {\n    /**\n     * Client class (abstract).\n     *\n     * @api private\n     */\n    constructor(id, server, transport, req, protocol) {\n        super();\n        this.id = id;\n        this.server = server;\n        this.upgrading = false;\n        this.upgraded = false;\n        this.readyState = \"opening\";\n        this.writeBuffer = [];\n        this.packetsFn = [];\n        this.sentCallbackFn = [];\n        this.cleanupFn = [];\n        this.request = req;\n        this.protocol = protocol;\n        // Cache IP since it might not be in the req later\n        if (req.websocket && req.websocket._socket) {\n            this.remoteAddress = req.websocket._socket.remoteAddress;\n        }\n        else {\n            this.remoteAddress = req.connection.remoteAddress;\n        }\n        this.checkIntervalTimer = null;\n        this.upgradeTimeoutTimer = null;\n        this.pingTimeoutTimer = null;\n        this.pingIntervalTimer = null;\n        this.setTransport(transport);\n        this.onOpen();\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    set readyState(state) {\n        debug(\"readyState updated from %s to %s\", this._readyState, state);\n        this._readyState = state;\n    }\n    /**\n     * Called upon transport considered open.\n     *\n     * @api private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        // sends an `open` packet\n        this.transport.sid = this.id;\n        this.sendPacket(\"open\", JSON.stringify({\n            sid: this.id,\n            upgrades: this.getAvailableUpgrades(),\n            pingInterval: this.server.opts.pingInterval,\n            pingTimeout: this.server.opts.pingTimeout,\n            maxPayload: this.server.opts.maxHttpBufferSize\n        }));\n        if (this.server.opts.initialPacket) {\n            this.sendPacket(\"message\", this.server.opts.initialPacket);\n        }\n        this.emit(\"open\");\n        if (this.protocol === 3) {\n            // in protocol v3, the client sends a ping, and the server answers with a pong\n            this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n        }\n        else {\n            // in protocol v4, the server sends a ping, and the client answers with a pong\n            this.schedulePing();\n        }\n    }\n    /**\n     * Called upon transport packet.\n     *\n     * @param {Object} packet\n     * @api private\n     */\n    onPacket(packet) {\n        if (\"open\" !== this.readyState) {\n            return debug(\"packet received with closed socket\");\n        }\n        // export packet event\n        debug(`received packet ${packet.type}`);\n        this.emit(\"packet\", packet);\n        // Reset ping timeout on any packet, incoming data is a good sign of\n        // other side's liveness\n        this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n        switch (packet.type) {\n            case \"ping\":\n                if (this.transport.protocol !== 3) {\n                    this.onError(\"invalid heartbeat direction\");\n                    return;\n                }\n                debug(\"got ping\");\n                this.sendPacket(\"pong\");\n                this.emit(\"heartbeat\");\n                break;\n            case \"pong\":\n                if (this.transport.protocol === 3) {\n                    this.onError(\"invalid heartbeat direction\");\n                    return;\n                }\n                debug(\"got pong\");\n                this.pingIntervalTimer.refresh();\n                this.emit(\"heartbeat\");\n                break;\n            case \"error\":\n                this.onClose(\"parse error\");\n                break;\n            case \"message\":\n                this.emit(\"data\", packet.data);\n                this.emit(\"message\", packet.data);\n                break;\n        }\n    }\n    /**\n     * Called upon transport error.\n     *\n     * @param {Error} error object\n     * @api private\n     */\n    onError(err) {\n        debug(\"transport error\");\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Pings client every `this.pingInterval` and expects response\n     * within `this.pingTimeout` or closes connection.\n     *\n     * @api private\n     */\n    schedulePing() {\n        this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {\n            debug(\"writing ping packet - expecting pong within %sms\", this.server.opts.pingTimeout);\n            this.sendPacket(\"ping\");\n            this.resetPingTimeout(this.server.opts.pingTimeout);\n        }, this.server.opts.pingInterval);\n    }\n    /**\n     * Resets ping timeout.\n     *\n     * @api private\n     */\n    resetPingTimeout(timeout) {\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {\n            if (this.readyState === \"closed\")\n                return;\n            this.onClose(\"ping timeout\");\n        }, timeout);\n    }\n    /**\n     * Attaches handlers for the given transport.\n     *\n     * @param {Transport} transport\n     * @api private\n     */\n    setTransport(transport) {\n        const onError = this.onError.bind(this);\n        const onPacket = this.onPacket.bind(this);\n        const flush = this.flush.bind(this);\n        const onClose = this.onClose.bind(this, \"transport close\");\n        this.transport = transport;\n        this.transport.once(\"error\", onError);\n        this.transport.on(\"packet\", onPacket);\n        this.transport.on(\"drain\", flush);\n        this.transport.once(\"close\", onClose);\n        // this function will manage packet events (also message callbacks)\n        this.setupSendCallback();\n        this.cleanupFn.push(function () {\n            transport.removeListener(\"error\", onError);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"drain\", flush);\n            transport.removeListener(\"close\", onClose);\n        });\n    }\n    /**\n     * Upgrades socket to the given transport\n     *\n     * @param {Transport} transport\n     * @api private\n     */\n    maybeUpgrade(transport) {\n        debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n        this.upgrading = true;\n        // set transport upgrade timer\n        this.upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {\n            debug(\"client did not complete upgrade - closing transport\");\n            cleanup();\n            if (\"open\" === transport.readyState) {\n                transport.close();\n            }\n        }, this.server.opts.upgradeTimeout);\n        const onPacket = packet => {\n            if (\"ping\" === packet.type && \"probe\" === packet.data) {\n                debug(\"got probe ping packet, sending pong\");\n                transport.send([{ type: \"pong\", data: \"probe\" }]);\n                this.emit(\"upgrading\", transport);\n                clearInterval(this.checkIntervalTimer);\n                this.checkIntervalTimer = setInterval(check, 100);\n            }\n            else if (\"upgrade\" === packet.type && this.readyState !== \"closed\") {\n                debug(\"got upgrade packet - upgrading\");\n                cleanup();\n                this.transport.discard();\n                this.upgraded = true;\n                this.clearTransport();\n                this.setTransport(transport);\n                this.emit(\"upgrade\", transport);\n                this.flush();\n                if (this.readyState === \"closing\") {\n                    transport.close(() => {\n                        this.onClose(\"forced close\");\n                    });\n                }\n            }\n            else {\n                cleanup();\n                transport.close();\n            }\n        };\n        // we force a polling cycle to ensure a fast upgrade\n        const check = () => {\n            if (\"polling\" === this.transport.name && this.transport.writable) {\n                debug(\"writing a noop packet to polling for fast upgrade\");\n                this.transport.send([{ type: \"noop\" }]);\n            }\n        };\n        const cleanup = () => {\n            this.upgrading = false;\n            clearInterval(this.checkIntervalTimer);\n            this.checkIntervalTimer = null;\n            (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer);\n            this.upgradeTimeoutTimer = null;\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"close\", onTransportClose);\n            transport.removeListener(\"error\", onError);\n            this.removeListener(\"close\", onClose);\n        };\n        const onError = err => {\n            debug(\"client did not complete upgrade - %s\", err);\n            cleanup();\n            transport.close();\n            transport = null;\n        };\n        const onTransportClose = () => {\n            onError(\"transport closed\");\n        };\n        const onClose = () => {\n            onError(\"socket closed\");\n        };\n        transport.on(\"packet\", onPacket);\n        transport.once(\"close\", onTransportClose);\n        transport.once(\"error\", onError);\n        this.once(\"close\", onClose);\n    }\n    /**\n     * Clears listeners and timers associated with current transport.\n     *\n     * @api private\n     */\n    clearTransport() {\n        let cleanup;\n        const toCleanUp = this.cleanupFn.length;\n        for (let i = 0; i < toCleanUp; i++) {\n            cleanup = this.cleanupFn.shift();\n            cleanup();\n        }\n        // silence further transport errors and prevent uncaught exceptions\n        this.transport.on(\"error\", function () {\n            debug(\"error triggered by discarded transport\");\n        });\n        // ensure transport won't stay open\n        this.transport.close();\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n    }\n    /**\n     * Called upon transport considered closed.\n     * Possible reasons: `ping timeout`, `client error`, `parse error`,\n     * `transport error`, `server close`, `transport close`\n     */\n    onClose(reason, description) {\n        if (\"closed\" !== this.readyState) {\n            this.readyState = \"closed\";\n            // clear timers\n            (0, timers_1.clearTimeout)(this.pingIntervalTimer);\n            (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n            clearInterval(this.checkIntervalTimer);\n            this.checkIntervalTimer = null;\n            (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer);\n            // clean writeBuffer in next tick, so developers can still\n            // grab the writeBuffer on 'close' event\n            process.nextTick(() => {\n                this.writeBuffer = [];\n            });\n            this.packetsFn = [];\n            this.sentCallbackFn = [];\n            this.clearTransport();\n            this.emit(\"close\", reason, description);\n        }\n    }\n    /**\n     * Setup and manage send callback\n     *\n     * @api private\n     */\n    setupSendCallback() {\n        // the message was sent successfully, execute the callback\n        const onDrain = () => {\n            if (this.sentCallbackFn.length > 0) {\n                const seqFn = this.sentCallbackFn.splice(0, 1)[0];\n                if (\"function\" === typeof seqFn) {\n                    debug(\"executing send callback\");\n                    seqFn(this.transport);\n                }\n                else if (Array.isArray(seqFn)) {\n                    debug(\"executing batch send callback\");\n                    const l = seqFn.length;\n                    let i = 0;\n                    for (; i < l; i++) {\n                        if (\"function\" === typeof seqFn[i]) {\n                            seqFn[i](this.transport);\n                        }\n                    }\n                }\n            }\n        };\n        this.transport.on(\"drain\", onDrain);\n        this.cleanupFn.push(() => {\n            this.transport.removeListener(\"drain\", onDrain);\n        });\n    }\n    /**\n     * Sends a message packet.\n     *\n     * @param {Object} data\n     * @param {Object} options\n     * @param {Function} callback\n     * @return {Socket} for chaining\n     * @api public\n     */\n    send(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    write(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type - packet type\n     * @param {String} data\n     * @param {Object} options\n     * @param {Function} callback\n     *\n     * @api private\n     */\n    sendPacket(type, data, options, callback) {\n        if (\"function\" === typeof options) {\n            callback = options;\n            options = null;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n            debug('sending packet \"%s\" (%s)', type, data);\n            const packet = {\n                type,\n                options\n            };\n            if (data)\n                packet.data = data;\n            // exports packetCreate event\n            this.emit(\"packetCreate\", packet);\n            this.writeBuffer.push(packet);\n            // add send callback to object, if defined\n            if (callback)\n                this.packetsFn.push(callback);\n            this.flush();\n        }\n    }\n    /**\n     * Attempts to flush the packets buffer.\n     *\n     * @api private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            this.writeBuffer.length) {\n            debug(\"flushing buffer to transport\");\n            this.emit(\"flush\", this.writeBuffer);\n            this.server.emit(\"flush\", this, this.writeBuffer);\n            const wbuf = this.writeBuffer;\n            this.writeBuffer = [];\n            if (!this.transport.supportsFraming) {\n                this.sentCallbackFn.push(this.packetsFn);\n            }\n            else {\n                this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n            }\n            this.packetsFn = [];\n            this.transport.send(wbuf);\n            this.emit(\"drain\");\n            this.server.emit(\"drain\", this);\n        }\n    }\n    /**\n     * Get available upgrades for this socket.\n     *\n     * @api private\n     */\n    getAvailableUpgrades() {\n        const availableUpgrades = [];\n        const allUpgrades = this.server.upgrades(this.transport.name);\n        let i = 0;\n        const l = allUpgrades.length;\n        for (; i < l; ++i) {\n            const upg = allUpgrades[i];\n            if (this.server.opts.transports.indexOf(upg) !== -1) {\n                availableUpgrades.push(upg);\n            }\n        }\n        return availableUpgrades;\n    }\n    /**\n     * Closes the socket and underlying transport.\n     *\n     * @param {Boolean} discard - optional, discard the transport\n     * @return {Socket} for chaining\n     * @api public\n     */\n    close(discard) {\n        if (\"open\" !== this.readyState)\n            return;\n        this.readyState = \"closing\";\n        if (this.writeBuffer.length) {\n            this.once(\"drain\", this.closeTransport.bind(this, discard));\n            return;\n        }\n        this.closeTransport(discard);\n    }\n    /**\n     * Closes the underlying transport.\n     *\n     * @param {Boolean} discard\n     * @api private\n     */\n    closeTransport(discard) {\n        if (discard)\n            this.transport.discard();\n        this.transport.close(this.onClose.bind(this, \"forced close\"));\n    }\n}\nexports.Socket = Socket;\n"]},"metadata":{},"sourceType":"script"}