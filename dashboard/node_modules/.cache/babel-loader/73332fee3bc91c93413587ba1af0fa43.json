{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nvar PatternParser = /*#__PURE__*/function () {\n  function PatternParser() {\n    _classCallCheck(this, PatternParser);\n  }\n  _createClass(PatternParser, [{\n    key: \"parse\",\n    value: function parse(pattern) {\n      this.context = [{\n        or: true,\n        instructions: []\n      }];\n      this.parsePattern(pattern);\n      if (this.context.length !== 1) {\n        throw new Error('Non-finalized contexts left when pattern parse ended');\n      }\n      var _this$context$ = this.context[0],\n        branches = _this$context$.branches,\n        instructions = _this$context$.instructions;\n      if (branches) {\n        return {\n          op: '|',\n          args: branches.concat([expandSingleElementArray(instructions)])\n        };\n      }\n      /* istanbul ignore if */\n\n      if (instructions.length === 0) {\n        throw new Error('Pattern is required');\n      }\n      if (instructions.length === 1) {\n        return instructions[0];\n      }\n      return instructions;\n    }\n  }, {\n    key: \"startContext\",\n    value: function startContext(context) {\n      this.context.push(context);\n    }\n  }, {\n    key: \"endContext\",\n    value: function endContext() {\n      this.context.pop();\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context[this.context.length - 1];\n    }\n  }, {\n    key: \"parsePattern\",\n    value: function parsePattern(pattern) {\n      if (!pattern) {\n        throw new Error('Pattern is required');\n      }\n      var match = pattern.match(OPERATOR);\n      if (!match) {\n        if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\n          throw new Error(\"Illegal characters found in a pattern: \".concat(pattern));\n        }\n        this.getContext().instructions = this.getContext().instructions.concat(pattern.split(''));\n        return;\n      }\n      var operator = match[1];\n      var before = pattern.slice(0, match.index);\n      var rightPart = pattern.slice(match.index + operator.length);\n      switch (operator) {\n        case '(?:':\n          if (before) {\n            this.parsePattern(before);\n          }\n          this.startContext({\n            or: true,\n            instructions: [],\n            branches: []\n          });\n          break;\n        case ')':\n          if (!this.getContext().or) {\n            throw new Error('\")\" operator must be preceded by \"(?:\" operator');\n          }\n          if (before) {\n            this.parsePattern(before);\n          }\n          if (this.getContext().instructions.length === 0) {\n            throw new Error('No instructions found after \"|\" operator in an \"or\" group');\n          }\n          var _this$getContext = this.getContext(),\n            branches = _this$getContext.branches;\n          branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '|',\n            args: branches\n          });\n          break;\n        case '|':\n          if (!this.getContext().or) {\n            throw new Error('\"|\" operator can only be used inside \"or\" groups');\n          }\n          if (before) {\n            this.parsePattern(before);\n          } // The top-level is an implicit \"or\" group, if required.\n\n          if (!this.getContext().branches) {\n            // `branches` are not defined only for the root implicit \"or\" operator.\n\n            /* istanbul ignore else */\n            if (this.context.length === 1) {\n              this.getContext().branches = [];\n            } else {\n              throw new Error('\"branches\" not found in an \"or\" group context');\n            }\n          }\n          this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.getContext().instructions = [];\n          break;\n        case '[':\n          if (before) {\n            this.parsePattern(before);\n          }\n          this.startContext({\n            oneOfSet: true\n          });\n          break;\n        case ']':\n          if (!this.getContext().oneOfSet) {\n            throw new Error('\"]\" operator must be preceded by \"[\" operator');\n          }\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '[]',\n            args: parseOneOfSet(before)\n          });\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unknown operator: \".concat(operator));\n      }\n      if (rightPart) {\n        this.parsePattern(rightPart);\n      }\n    }\n  }]);\n  return PatternParser;\n}();\nexport { PatternParser as default };\nfunction parseOneOfSet(pattern) {\n  var values = [];\n  var i = 0;\n  while (i < pattern.length) {\n    if (pattern[i] === '-') {\n      if (i === 0 || i === pattern.length - 1) {\n        throw new Error(\"Couldn't parse a one-of set pattern: \".concat(pattern));\n      }\n      var prevValue = pattern[i - 1].charCodeAt(0) + 1;\n      var nextValue = pattern[i + 1].charCodeAt(0) - 1;\n      var value = prevValue;\n      while (value <= nextValue) {\n        values.push(String.fromCharCode(value));\n        value++;\n      }\n    } else {\n      values.push(pattern[i]);\n    }\n    i++;\n  }\n  return values;\n}\nvar ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/;\nvar OPERATOR = new RegExp(\n// any of:\n'(' +\n// or operator\n'\\\\|' +\n// or\n'|' +\n// or group start\n'\\\\(\\\\?\\\\:' +\n// or\n'|' +\n// or group end\n'\\\\)' +\n// or\n'|' +\n// one-of set start\n'\\\\[' +\n// or\n'|' +\n// one-of set end\n'\\\\]' + ')');\nfunction expandSingleElementArray(array) {\n  if (array.length === 1) {\n    return array[0];\n  }\n  return array;\n}","map":{"version":3,"sources":["../source/AsYouTypeFormatter.PatternParser.js"],"names":["PatternParser","pattern","context","or","instructions","parsePattern","length","Error","branches","op","args","concat","expandSingleElementArray","push","pop","match","OPERATOR","ILLEGAL_CHARACTER_REGEXP","test","getContext","split","operator","before","slice","index","rightPart","startContext","endContext","oneOfSet","parseOneOfSet","values","i","prevValue","charCodeAt","nextValue","value","String","fromCharCode","RegExp","array"],"mappings":"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","sourcesContent":["export default class PatternParser {\r\n\tparse(pattern) {\r\n\t\tthis.context = [{\r\n\t\t\tor: true,\r\n\t\t\tinstructions: []\r\n\t\t}]\r\n\r\n\t\tthis.parsePattern(pattern)\r\n\r\n\t\tif (this.context.length !== 1) {\r\n\t\t\tthrow new Error('Non-finalized contexts left when pattern parse ended')\r\n\t\t}\r\n\r\n\t\tconst { branches, instructions } = this.context[0]\r\n\r\n\t\tif (branches) {\r\n\t\t\treturn {\r\n\t\t\t\top: '|',\r\n\t\t\t\targs: branches.concat([\r\n\t\t\t\t\texpandSingleElementArray(instructions)\r\n\t\t\t\t])\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* istanbul ignore if */\r\n\t\tif (instructions.length === 0) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tif (instructions.length === 1) {\r\n\t\t\treturn instructions[0]\r\n\t\t}\r\n\r\n\t\treturn instructions\r\n\t}\r\n\r\n\tstartContext(context) {\r\n\t\tthis.context.push(context)\r\n\t}\r\n\r\n\tendContext() {\r\n\t\tthis.context.pop()\r\n\t}\r\n\r\n\tgetContext() {\r\n\t\treturn this.context[this.context.length - 1]\r\n\t}\r\n\r\n\tparsePattern(pattern) {\r\n\t\tif (!pattern) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tconst match = pattern.match(OPERATOR)\r\n\t\tif (!match) {\r\n\t\t\tif (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\r\n\t\t\t\tthrow new Error(`Illegal characters found in a pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tthis.getContext().instructions = this.getContext().instructions.concat(\r\n\t\t\t\tpattern.split('')\r\n\t\t\t)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst operator = match[1]\r\n\t\tconst before = pattern.slice(0, match.index)\r\n\t\tconst rightPart = pattern.slice(match.index + operator.length)\r\n\r\n\t\tswitch (operator) {\r\n\t\t\tcase '(?:':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\tor: true,\r\n\t\t\t\t\tinstructions: [],\r\n\t\t\t\t\tbranches: []\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ')':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\")\" operator must be preceded by \"(?:\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.getContext().instructions.length === 0) {\r\n\t\t\t\t\tthrow new Error('No instructions found after \"|\" operator in an \"or\" group')\r\n\t\t\t\t}\r\n\t\t\t\tconst { branches } = this.getContext()\r\n\t\t\t\tbranches.push(\r\n\t\t\t\t\texpandSingleElementArray(\r\n\t\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '|',\r\n\t\t\t\t\targs: branches\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '|':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\"|\" operator can only be used inside \"or\" groups')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\t// The top-level is an implicit \"or\" group, if required.\r\n\t\t\t\tif (!this.getContext().branches) {\r\n\t\t\t\t\t// `branches` are not defined only for the root implicit \"or\" operator.\r\n\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\tif (this.context.length === 1) {\r\n\t\t\t\t\t\tthis.getContext().branches = []\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error('\"branches\" not found in an \"or\" group context')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.getContext().branches.push(\r\n\t\t\t\t\texpandSingleElementArray(\r\n\t\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\tthis.getContext().instructions = []\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '[':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\toneOfSet: true\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ']':\r\n\t\t\t\tif (!this.getContext().oneOfSet) {\r\n\t\t\t\t\tthrow new Error('\"]\" operator must be preceded by \"[\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '[]',\r\n\t\t\t\t\targs: parseOneOfSet(before)\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown operator: ${operator}`)\r\n\t\t}\r\n\r\n\t\tif (rightPart) {\r\n\t\t\tthis.parsePattern(rightPart)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction parseOneOfSet(pattern) {\r\n\tconst values = []\r\n\tlet i = 0\r\n\twhile (i < pattern.length) {\r\n\t\tif (pattern[i] === '-') {\r\n\t\t\tif (i === 0 || i === pattern.length - 1) {\r\n\t\t\t\tthrow new Error(`Couldn't parse a one-of set pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tconst prevValue = pattern[i - 1].charCodeAt(0) + 1\r\n\t\t\tconst nextValue = pattern[i + 1].charCodeAt(0) - 1\r\n\t\t\tlet value = prevValue\r\n\t\t\twhile (value <= nextValue) {\r\n\t\t\t\tvalues.push(String.fromCharCode(value))\r\n\t\t\t\tvalue++\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalues.push(pattern[i])\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn values\r\n}\r\n\r\nconst ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/\r\n\r\nconst OPERATOR = new RegExp(\r\n\t// any of:\r\n\t'(' +\r\n\t\t// or operator\r\n\t\t'\\\\|' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group start\r\n\t\t'\\\\(\\\\?\\\\:' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group end\r\n\t\t'\\\\)' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set start\r\n\t\t'\\\\[' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set end\r\n\t\t'\\\\]' +\r\n\t')'\r\n)\r\n\r\nfunction expandSingleElementArray(array) {\r\n\tif (array.length === 1) {\r\n\t\treturn array[0]\r\n\t}\r\n\treturn array\r\n}"]},"metadata":{},"sourceType":"module"}