{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _regeneratorRuntime = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _asyncToGenerator = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uServer = void 0;\n\nvar debug_1 = require(\"debug\");\n\nvar server_1 = require(\"./server\");\n\nvar transports_uws_1 = require(\"./transports-uws\");\n\nvar debug = (0, debug_1.default)(\"engine:uws\");\n\nvar uServer = /*#__PURE__*/function (_server_1$BaseServer) {\n  _inherits(uServer, _server_1$BaseServer);\n\n  var _super = _createSuper(uServer);\n\n  function uServer() {\n    _classCallCheck(this, uServer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(uServer, [{\n    key: \"init\",\n    value: function init() {}\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {}\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"prepare\",\n    value: function prepare(req, res) {\n      req.method = req.getMethod().toUpperCase();\n      var params = new URLSearchParams(req.getQuery());\n      req._query = Object.fromEntries(params.entries());\n      req.headers = {};\n      req.forEach(function (key, value) {\n        req.headers[key] = value;\n      });\n      req.connection = {\n        remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()\n      };\n      res.onAborted(function () {\n        debug(\"response has been aborted\");\n      });\n    }\n  }, {\n    key: \"createTransport\",\n    value: function createTransport(transportName, req) {\n      return new transports_uws_1.default[transportName](req);\n    }\n    /**\n     * Attach the engine to a µWebSockets.js server\n     * @param app\n     * @param options\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(app\n    /* : TemplatedApp */\n    ) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var path = (options.path || \"/engine.io\").replace(/\\/$/, \"\") + \"/\";\n      app.any(path, this.handleRequest.bind(this)) //\n      .ws(path, {\n        compression: options.compression,\n        idleTimeout: options.idleTimeout,\n        maxBackpressure: options.maxBackpressure,\n        maxPayloadLength: this.opts.maxHttpBufferSize,\n        upgrade: this.handleUpgrade.bind(this),\n        open: function open(ws) {\n          ws.transport.socket = ws;\n          ws.transport.writable = true;\n          ws.transport.emit(\"drain\");\n        },\n        message: function message(ws, _message, isBinary) {\n          ws.transport.onData(isBinary ? _message : Buffer.from(_message).toString());\n        },\n        close: function close(ws, code, message) {\n          ws.transport.onClose(code, message);\n        }\n      });\n    }\n  }, {\n    key: \"handleRequest\",\n    value: function handleRequest(res, req) {\n      var _this = this;\n\n      debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n      this.prepare(req, res);\n      req.res = res;\n\n      var callback = function callback(errorCode, errorContext) {\n        if (errorCode !== undefined) {\n          _this.emit(\"connection_error\", {\n            req: req,\n            code: errorCode,\n            message: server_1.Server.errorMessages[errorCode],\n            context: errorContext\n          });\n\n          _this.abortRequest(req.res, errorCode, errorContext);\n\n          return;\n        }\n\n        if (req._query.sid) {\n          debug(\"setting new request for existing client\");\n\n          _this.clients[req._query.sid].transport.onRequest(req);\n        } else {\n          var closeConnection = function closeConnection(errorCode, errorContext) {\n            return _this.abortRequest(res, errorCode, errorContext);\n          };\n\n          _this.handshake(req._query.transport, req, closeConnection);\n        }\n      };\n\n      if (this.corsMiddleware) {\n        // needed to buffer headers until the status is computed\n        req.res = new ResponseWrapper(res);\n        this.corsMiddleware.call(null, req, req.res, function () {\n          _this.verify(req, false, callback);\n        });\n      } else {\n        this.verify(req, false, callback);\n      }\n    }\n  }, {\n    key: \"handleUpgrade\",\n    value: function handleUpgrade(res, req, context) {\n      var _this2 = this;\n\n      debug(\"on upgrade\");\n      this.prepare(req, res); // @ts-ignore\n\n      req.res = res;\n      this.verify(req, true, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(errorCode, errorContext) {\n          var id, transport, client;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (!errorCode) {\n                    _context.next = 4;\n                    break;\n                  }\n\n                  _this2.emit(\"connection_error\", {\n                    req: req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext\n                  });\n\n                  _this2.abortRequest(res, errorCode, errorContext);\n\n                  return _context.abrupt(\"return\");\n\n                case 4:\n                  id = req._query.sid;\n\n                  if (!id) {\n                    _context.next = 10;\n                    break;\n                  }\n\n                  client = _this2.clients[id];\n\n                  if (!client) {\n                    debug(\"upgrade attempt for closed client\");\n                    res.close();\n                  } else if (client.upgrading) {\n                    debug(\"transport has already been trying to upgrade\");\n                    res.close();\n                  } else if (client.upgraded) {\n                    debug(\"transport had already been upgraded\");\n                    res.close();\n                  } else {\n                    debug(\"upgrading existing transport\");\n                    transport = _this2.createTransport(req._query.transport, req);\n                    client.maybeUpgrade(transport);\n                  }\n\n                  _context.next = 15;\n                  break;\n\n                case 10:\n                  _context.next = 12;\n                  return _this2.handshake(req._query.transport, req, function (errorCode, errorContext) {\n                    return _this2.abortRequest(res, errorCode, errorContext);\n                  });\n\n                case 12:\n                  transport = _context.sent;\n\n                  if (transport) {\n                    _context.next = 15;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\");\n\n                case 15:\n                  res.upgrade({\n                    transport: transport\n                  }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n\n                case 16:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n  }, {\n    key: \"abortRequest\",\n    value: function abortRequest(res, errorCode, errorContext) {\n      var statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? \"403 Forbidden\" : \"400 Bad Request\";\n      var message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];\n      res.writeStatus(statusCode);\n      res.writeHeader(\"Content-Type\", \"application/json\");\n      res.end(JSON.stringify({\n        code: errorCode,\n        message: message\n      }));\n    }\n  }]);\n\n  return uServer;\n}(server_1.BaseServer);\n\nexports.uServer = uServer;\n\nvar ResponseWrapper = /*#__PURE__*/function () {\n  function ResponseWrapper(res) {\n    _classCallCheck(this, ResponseWrapper);\n\n    this.res = res;\n    this.statusWritten = false;\n    this.headers = [];\n  }\n\n  _createClass(ResponseWrapper, [{\n    key: \"statusCode\",\n    set: function set(status) {\n      this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n    }\n  }, {\n    key: \"setHeader\",\n    value: function setHeader(key, value) {\n      this.writeHeader(key, value);\n    } // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n\n  }, {\n    key: \"getHeader\",\n    value: function getHeader() {}\n  }, {\n    key: \"writeStatus\",\n    value: function writeStatus(status) {\n      this.res.writeStatus(status);\n      this.statusWritten = true;\n      this.writeBufferedHeaders();\n    }\n  }, {\n    key: \"writeHeader\",\n    value: function writeHeader(key, value) {\n      if (key === \"Content-Length\") {\n        // the content length is automatically added by uWebSockets.js\n        return;\n      }\n\n      if (this.statusWritten) {\n        this.res.writeHeader(key, value);\n      } else {\n        this.headers.push([key, value]);\n      }\n    }\n  }, {\n    key: \"writeBufferedHeaders\",\n    value: function writeBufferedHeaders() {\n      var _this3 = this;\n\n      this.headers.forEach(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            key = _ref3[0],\n            value = _ref3[1];\n\n        _this3.res.writeHeader(key, value);\n      });\n    }\n  }, {\n    key: \"end\",\n    value: function end(data) {\n      if (!this.statusWritten) {\n        // status will be inferred as \"200 OK\"\n        this.writeBufferedHeaders();\n      }\n\n      this.res.end(data);\n    }\n  }, {\n    key: \"onData\",\n    value: function onData(fn) {\n      this.res.onData(fn);\n    }\n  }, {\n    key: \"onAborted\",\n    value: function onAborted(fn) {\n      this.res.onAborted(fn);\n    }\n  }]);\n\n  return ResponseWrapper;\n}();","map":{"version":3,"sources":["/home/tj/fl-carla/node_modules/engine.io/build/userver.js"],"names":["Object","defineProperty","exports","value","uServer","debug_1","require","server_1","transports_uws_1","debug","default","req","res","method","getMethod","toUpperCase","params","URLSearchParams","getQuery","_query","fromEntries","entries","headers","forEach","key","connection","remoteAddress","Buffer","from","getRemoteAddressAsText","toString","onAborted","transportName","app","options","path","replace","any","handleRequest","bind","ws","compression","idleTimeout","maxBackpressure","maxPayloadLength","opts","maxHttpBufferSize","upgrade","handleUpgrade","open","transport","socket","writable","emit","message","isBinary","onData","close","code","onClose","getUrl","prepare","callback","errorCode","errorContext","undefined","Server","errorMessages","context","abortRequest","sid","clients","onRequest","closeConnection","handshake","corsMiddleware","ResponseWrapper","call","verify","id","client","upgrading","upgraded","createTransport","maybeUpgrade","getHeader","statusCode","errors","FORBIDDEN","writeStatus","writeHeader","end","JSON","stringify","BaseServer","statusWritten","status","writeBufferedHeaders","push","data","fn"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.uServer = void 0;\nconst debug_1 = require(\"debug\");\nconst server_1 = require(\"./server\");\nconst transports_uws_1 = require(\"./transports-uws\");\nconst debug = (0, debug_1.default)(\"engine:uws\");\nclass uServer extends server_1.BaseServer {\n    init() { }\n    cleanup() { }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n    prepare(req, res) {\n        req.method = req.getMethod().toUpperCase();\n        const params = new URLSearchParams(req.getQuery());\n        req._query = Object.fromEntries(params.entries());\n        req.headers = {};\n        req.forEach((key, value) => {\n            req.headers[key] = value;\n        });\n        req.connection = {\n            remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()\n        };\n        res.onAborted(() => {\n            debug(\"response has been aborted\");\n        });\n    }\n    createTransport(transportName, req) {\n        return new transports_uws_1.default[transportName](req);\n    }\n    /**\n     * Attach the engine to a µWebSockets.js server\n     * @param app\n     * @param options\n     */\n    attach(app /* : TemplatedApp */, options = {}) {\n        const path = (options.path || \"/engine.io\").replace(/\\/$/, \"\") + \"/\";\n        app\n            .any(path, this.handleRequest.bind(this))\n            //\n            .ws(path, {\n            compression: options.compression,\n            idleTimeout: options.idleTimeout,\n            maxBackpressure: options.maxBackpressure,\n            maxPayloadLength: this.opts.maxHttpBufferSize,\n            upgrade: this.handleUpgrade.bind(this),\n            open: ws => {\n                ws.transport.socket = ws;\n                ws.transport.writable = true;\n                ws.transport.emit(\"drain\");\n            },\n            message: (ws, message, isBinary) => {\n                ws.transport.onData(isBinary ? message : Buffer.from(message).toString());\n            },\n            close: (ws, code, message) => {\n                ws.transport.onClose(code, message);\n            }\n        });\n    }\n    handleRequest(res, req) {\n        debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n        this.prepare(req, res);\n        req.res = res;\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                this.abortRequest(req.res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                this.clients[req._query.sid].transport.onRequest(req);\n            }\n            else {\n                const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        if (this.corsMiddleware) {\n            // needed to buffer headers until the status is computed\n            req.res = new ResponseWrapper(res);\n            this.corsMiddleware.call(null, req, req.res, () => {\n                this.verify(req, false, callback);\n            });\n        }\n        else {\n            this.verify(req, false, callback);\n        }\n    }\n    handleUpgrade(res, req, context) {\n        debug(\"on upgrade\");\n        this.prepare(req, res);\n        // @ts-ignore\n        req.res = res;\n        this.verify(req, true, async (errorCode, errorContext) => {\n            if (errorCode) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                this.abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            const id = req._query.sid;\n            let transport;\n            if (id) {\n                const client = this.clients[id];\n                if (!client) {\n                    debug(\"upgrade attempt for closed client\");\n                    res.close();\n                }\n                else if (client.upgrading) {\n                    debug(\"transport has already been trying to upgrade\");\n                    res.close();\n                }\n                else if (client.upgraded) {\n                    debug(\"transport had already been upgraded\");\n                    res.close();\n                }\n                else {\n                    debug(\"upgrading existing transport\");\n                    transport = this.createTransport(req._query.transport, req);\n                    client.maybeUpgrade(transport);\n                }\n            }\n            else {\n                transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));\n                if (!transport) {\n                    return;\n                }\n            }\n            res.upgrade({\n                transport\n            }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n        });\n    }\n    abortRequest(res, errorCode, errorContext) {\n        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN\n            ? \"403 Forbidden\"\n            : \"400 Bad Request\";\n        const message = errorContext && errorContext.message\n            ? errorContext.message\n            : server_1.Server.errorMessages[errorCode];\n        res.writeStatus(statusCode);\n        res.writeHeader(\"Content-Type\", \"application/json\");\n        res.end(JSON.stringify({\n            code: errorCode,\n            message\n        }));\n    }\n}\nexports.uServer = uServer;\nclass ResponseWrapper {\n    constructor(res) {\n        this.res = res;\n        this.statusWritten = false;\n        this.headers = [];\n    }\n    set statusCode(status) {\n        this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n    }\n    setHeader(key, value) {\n        this.writeHeader(key, value);\n    }\n    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n    getHeader() { }\n    writeStatus(status) {\n        this.res.writeStatus(status);\n        this.statusWritten = true;\n        this.writeBufferedHeaders();\n    }\n    writeHeader(key, value) {\n        if (key === \"Content-Length\") {\n            // the content length is automatically added by uWebSockets.js\n            return;\n        }\n        if (this.statusWritten) {\n            this.res.writeHeader(key, value);\n        }\n        else {\n            this.headers.push([key, value]);\n        }\n    }\n    writeBufferedHeaders() {\n        this.headers.forEach(([key, value]) => {\n            this.res.writeHeader(key, value);\n        });\n    }\n    end(data) {\n        if (!this.statusWritten) {\n            // status will be inferred as \"200 OK\"\n            this.writeBufferedHeaders();\n        }\n        this.res.end(data);\n    }\n    onData(fn) {\n        this.res.onData(fn);\n    }\n    onAborted(fn) {\n        this.res.onAborted(fn);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}