{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport isViablePhoneNumber from './isViablePhoneNumber.js'; // https://www.ietf.org/rfc/rfc3966.txt\n\n/**\r\n * @param  {string} text - Phone URI (RFC 3966).\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\n\nexport function parseRFC3966(text) {\n  var number;\n  var ext; // Replace \"tel:\" with \"tel=\" for parsing convenience.\n\n  text = text.replace(/^tel:/, 'tel=');\n  for (var _iterator = _createForOfIteratorHelperLoose(text.split(';')), _step; !(_step = _iterator()).done;) {\n    var part = _step.value;\n    var _part$split = part.split('='),\n      _part$split2 = _slicedToArray(_part$split, 2),\n      name = _part$split2[0],\n      value = _part$split2[1];\n    switch (name) {\n      case 'tel':\n        number = value;\n        break;\n      case 'ext':\n        ext = value;\n        break;\n      case 'phone-context':\n        // Only \"country contexts\" are supported.\n        // \"Domain contexts\" are ignored.\n        if (value[0] === '+') {\n          number = value + number;\n        }\n        break;\n    }\n  } // If the phone number is not viable, then abort.\n\n  if (!isViablePhoneNumber(number)) {\n    return {};\n  }\n  var result = {\n    number: number\n  };\n  if (ext) {\n    result.ext = ext;\n  }\n  return result;\n}\n/**\r\n * @param  {object} - `{ ?number, ?extension }`.\r\n * @return {string} Phone URI (RFC 3966).\r\n */\n\nexport function formatRFC3966(_ref) {\n  var number = _ref.number,\n    ext = _ref.ext;\n  if (!number) {\n    return '';\n  }\n  if (number[0] !== '+') {\n    throw new Error(\"\\\"formatRFC3966()\\\" expects \\\"number\\\" to be in E.164 format.\");\n  }\n  return \"tel:\".concat(number).concat(ext ? ';ext=' + ext : '');\n}","map":{"version":3,"sources":["../../source/helpers/RFC3966.js"],"names":["isViablePhoneNumber","parseRFC3966","text","number","ext","replace","part","split","name","value","result","formatRFC3966","Error"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,mBAAP,MAAgC,0BAAhC,C,CAEA;;AAEA;AACA;AACA;AACA;;AACA,OAAO,SAASC,YAAT,CAAsBC,IAAtB,EAA4B;EAClC,IAAIC,MAAJ;EACA,IAAIC,GAAJ,CAFkC,CAIlC;;EACAF,IAAI,GAAGA,IAAI,CAACG,OAALH,CAAa,OAAbA,EAAsB,MAAtBA,CAAPA;EAEA,KAAA,IAAA,SAAA,GAAA,+BAAA,CAAmBA,IAAI,CAACK,KAALL,CAAW,GAAXA,CAAnB,CAAA,EAAA,KAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,CAAA,CAAA,EAAA,IAAA,GAAoC;IAAA,IAAzBI,IAAyB,GAAA,KAAA,CAAA,KAAA;IACnC,IAAA,WAAA,GAAsBA,IAAI,CAACC,KAALD,CAAW,GAAXA,CAAtB;MAAA,YAAA,GAAA,cAAA,CAAA,WAAA,EAAA,CAAA,CAAA;MAAOE,IAAP,GAAA,YAAA,CAAA,CAAA,CAAA;MAAaC,KAAb,GAAA,YAAA,CAAA,CAAA,CAAA;IACA,QAAQD,IAAR;MACC,KAAK,KAAL;QACCL,MAAM,GAAGM,KAATN;QACA;MACD,KAAK,KAAL;QACCC,GAAG,GAAGK,KAANL;QACA;MACD,KAAK,eAAL;QACC;QACA;QACA,IAAIK,KAAK,CAAC,CAAD,CAALA,KAAa,GAAjB,EAAsB;UACrBN,MAAM,GAAGM,KAAK,GAAGN,MAAjBA;QACA;QACD;IAbF;EAeA,CAxBiC,CA0BlC;;EACA,IAAI,CAACH,mBAAmB,CAACG,MAAD,CAAxB,EAAkC;IACjC,OAAO,CAAA,CAAP;EACA;EAED,IAAMO,MAAM,GAAG;IAAEP,MAAM,EAANA;EAAF,CAAf;EACA,IAAIC,GAAJ,EAAS;IACRM,MAAM,CAACN,GAAPM,GAAaN,GAAbM;EACA;EACD,OAAOA,MAAP;AACA;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASC,aAAT,CAAA,IAAA,EAAwC;EAAA,IAAfR,MAAe,GAAA,IAAA,CAAfA,MAAe;IAAPC,GAAO,GAAA,IAAA,CAAPA,GAAO;EAC9C,IAAI,CAACD,MAAL,EAAa;IACZ,OAAO,EAAP;EACA;EACD,IAAIA,MAAM,CAAC,CAAD,CAANA,KAAc,GAAlB,EAAuB;IACtB,MAAM,IAAIS,KAAJ,CAAA,+DAAA,CAAN;EACA;EACD,OAAA,MAAA,CAAA,MAAA,CAAcT,MAAd,CAAA,CAAA,MAAA,CAAuBC,GAAG,GAAG,OAAA,GAAUA,GAAb,GAAmB,EAA7C,CAAA;AACA","sourcesContent":["import isViablePhoneNumber from './isViablePhoneNumber.js'\r\n\r\n// https://www.ietf.org/rfc/rfc3966.txt\r\n\r\n/**\r\n * @param  {string} text - Phone URI (RFC 3966).\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nexport function parseRFC3966(text) {\r\n\tlet number\r\n\tlet ext\r\n\r\n\t// Replace \"tel:\" with \"tel=\" for parsing convenience.\r\n\ttext = text.replace(/^tel:/, 'tel=')\r\n\r\n\tfor (const part of text.split(';')) {\r\n\t\tconst [name, value] = part.split('=')\r\n\t\tswitch (name) {\r\n\t\t\tcase 'tel':\r\n\t\t\t\tnumber = value\r\n\t\t\t\tbreak\r\n\t\t\tcase 'ext':\r\n\t\t\t\text = value\r\n\t\t\t\tbreak\r\n\t\t\tcase 'phone-context':\r\n\t\t\t\t// Only \"country contexts\" are supported.\r\n\t\t\t\t// \"Domain contexts\" are ignored.\r\n\t\t\t\tif (value[0] === '+') {\r\n\t\t\t\t\tnumber = value + number\r\n\t\t\t\t}\r\n\t\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!isViablePhoneNumber(number)) {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst result = { number }\r\n\tif (ext) {\r\n\t\tresult.ext = ext\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * @param  {object} - `{ ?number, ?extension }`.\r\n * @return {string} Phone URI (RFC 3966).\r\n */\r\nexport function formatRFC3966({ number, ext }) {\r\n\tif (!number) {\r\n\t\treturn ''\r\n\t}\r\n\tif (number[0] !== '+') {\r\n\t\tthrow new Error(`\"formatRFC3966()\" expects \"number\" to be in E.164 format.`)\r\n\t}\r\n\treturn `tel:${number}${ext ? ';ext=' + ext : ''}`\r\n}"]},"metadata":{},"sourceType":"module"}