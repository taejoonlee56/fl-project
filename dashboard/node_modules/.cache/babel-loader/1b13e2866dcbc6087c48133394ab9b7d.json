{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParentNamespace = void 0;\n\nvar namespace_1 = require(\"./namespace\");\n\nvar ParentNamespace = /*#__PURE__*/function (_namespace_1$Namespac) {\n  _inherits(ParentNamespace, _namespace_1$Namespac);\n\n  var _super = _createSuper(ParentNamespace);\n\n  function ParentNamespace(server) {\n    var _this;\n\n    _classCallCheck(this, ParentNamespace);\n\n    _this = _super.call(this, server, \"/_\" + ParentNamespace.count++);\n    _this.children = new Set();\n    return _this;\n  }\n  /**\n   * @private\n   */\n\n\n  _createClass(ParentNamespace, [{\n    key: \"_initAdapter\",\n    value: function _initAdapter() {\n      var _this2 = this;\n\n      var broadcast = function broadcast(packet, opts) {\n        _this2.children.forEach(function (nsp) {\n          nsp.adapter.broadcast(packet, opts);\n        });\n      }; // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n\n\n      this.adapter = {\n        broadcast: broadcast\n      };\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(ev) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      this.children.forEach(function (nsp) {\n        nsp.emit.apply(nsp, [ev].concat(args));\n      });\n      return true;\n    }\n  }, {\n    key: \"createChild\",\n    value: function createChild(name) {\n      var namespace = new namespace_1.Namespace(this.server, name);\n      namespace._fns = this._fns.slice(0);\n      this.listeners(\"connect\").forEach(function (listener) {\n        return namespace.on(\"connect\", listener);\n      });\n      this.listeners(\"connection\").forEach(function (listener) {\n        return namespace.on(\"connection\", listener);\n      });\n      this.children.add(namespace);\n\n      this.server._nsps.set(name, namespace);\n\n      return namespace;\n    }\n  }, {\n    key: \"fetchSockets\",\n    value: function fetchSockets() {\n      // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n      // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n      // the behavior for namespaces created with a function is less clear\n      // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n      // may exist on one node but not exist on another (since it is created upon client connection)\n      throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n  }]);\n\n  return ParentNamespace;\n}(namespace_1.Namespace);\n\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;","map":{"version":3,"sources":["/home/tj/fl-carla/node_modules/socket.io/dist/parent-namespace.js"],"names":["Object","defineProperty","exports","value","ParentNamespace","namespace_1","require","server","count","children","Set","broadcast","packet","opts","forEach","nsp","adapter","ev","args","emit","name","namespace","Namespace","_fns","slice","listeners","listener","on","add","_nsps","set","Error"],"mappings":"AAAA;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0B,KAAK,CAA/B;;AACA,IAAMC,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;;IACMF,e;;;;;AACF,2BAAYG,MAAZ,EAAoB;AAAA;;AAAA;;AAChB,8BAAMA,MAAN,EAAc,OAAOH,eAAe,CAACI,KAAhB,EAArB;AACA,UAAKC,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AAFgB;AAGnB;AACD;AACJ;AACA;;;;;WACI,wBAAe;AAAA;;AACX,UAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,MAAD,EAASC,IAAT,EAAkB;AAChC,QAAA,MAAI,CAACJ,QAAL,CAAcK,OAAd,CAAsB,UAACC,GAAD,EAAS;AAC3BA,UAAAA,GAAG,CAACC,OAAJ,CAAYL,SAAZ,CAAsBC,MAAtB,EAA8BC,IAA9B;AACH,SAFD;AAGH,OAJD,CADW,CAMX;;;AACA,WAAKG,OAAL,GAAe;AAAEL,QAAAA,SAAS,EAATA;AAAF,OAAf;AACH;;;WACD,cAAKM,EAAL,EAAkB;AAAA,wCAANC,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACd,WAAKT,QAAL,CAAcK,OAAd,CAAsB,UAACC,GAAD,EAAS;AAC3BA,QAAAA,GAAG,CAACI,IAAJ,OAAAJ,GAAG,GAAME,EAAN,SAAaC,IAAb,EAAH;AACH,OAFD;AAGA,aAAO,IAAP;AACH;;;WACD,qBAAYE,IAAZ,EAAkB;AACd,UAAMC,SAAS,GAAG,IAAIhB,WAAW,CAACiB,SAAhB,CAA0B,KAAKf,MAA/B,EAAuCa,IAAvC,CAAlB;AACAC,MAAAA,SAAS,CAACE,IAAV,GAAiB,KAAKA,IAAL,CAAUC,KAAV,CAAgB,CAAhB,CAAjB;AACA,WAAKC,SAAL,CAAe,SAAf,EAA0BX,OAA1B,CAAkC,UAACY,QAAD;AAAA,eAAcL,SAAS,CAACM,EAAV,CAAa,SAAb,EAAwBD,QAAxB,CAAd;AAAA,OAAlC;AACA,WAAKD,SAAL,CAAe,YAAf,EAA6BX,OAA7B,CAAqC,UAACY,QAAD;AAAA,eAAcL,SAAS,CAACM,EAAV,CAAa,YAAb,EAA2BD,QAA3B,CAAd;AAAA,OAArC;AACA,WAAKjB,QAAL,CAAcmB,GAAd,CAAkBP,SAAlB;;AACA,WAAKd,MAAL,CAAYsB,KAAZ,CAAkBC,GAAlB,CAAsBV,IAAtB,EAA4BC,SAA5B;;AACA,aAAOA,SAAP;AACH;;;WACD,wBAAe;AACX;AACA;AACA;AACA;AACA;AACA,YAAM,IAAIU,KAAJ,CAAU,sDAAV,CAAN;AACH;;;;EAvCyB1B,WAAW,CAACiB,S;;AAyC1CpB,OAAO,CAACE,eAAR,GAA0BA,eAA1B;AACAA,eAAe,CAACI,KAAhB,GAAwB,CAAxB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParentNamespace = void 0;\nconst namespace_1 = require(\"./namespace\");\nclass ParentNamespace extends namespace_1.Namespace {\n    constructor(server) {\n        super(server, \"/_\" + ParentNamespace.count++);\n        this.children = new Set();\n    }\n    /**\n     * @private\n     */\n    _initAdapter() {\n        const broadcast = (packet, opts) => {\n            this.children.forEach((nsp) => {\n                nsp.adapter.broadcast(packet, opts);\n            });\n        };\n        // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n        this.adapter = { broadcast };\n    }\n    emit(ev, ...args) {\n        this.children.forEach((nsp) => {\n            nsp.emit(ev, ...args);\n        });\n        return true;\n    }\n    createChild(name) {\n        const namespace = new namespace_1.Namespace(this.server, name);\n        namespace._fns = this._fns.slice(0);\n        this.listeners(\"connect\").forEach((listener) => namespace.on(\"connect\", listener));\n        this.listeners(\"connection\").forEach((listener) => namespace.on(\"connection\", listener));\n        this.children.add(namespace);\n        this.server._nsps.set(name, namespace);\n        return namespace;\n    }\n    fetchSockets() {\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n        // the behavior for namespaces created with a function is less clear\n        // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n        // may exist on one node but not exist on another (since it is created upon client connection)\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n"]},"metadata":{},"sourceType":"script"}