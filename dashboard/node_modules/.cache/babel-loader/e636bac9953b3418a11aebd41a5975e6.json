{"ast":null,"code":"import { ERROR_PACKET, PACKET_TYPES_REVERSE } from \"./commons.js\";\nimport { decode } from \"./contrib/base64-arraybuffer.js\";\nvar withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n\nvar decodePacket = function decodePacket(encodedPacket, binaryType) {\n  if (typeof encodedPacket !== \"string\") {\n    return {\n      type: \"message\",\n      data: mapBinary(encodedPacket, binaryType)\n    };\n  }\n\n  var type = encodedPacket.charAt(0);\n\n  if (type === \"b\") {\n    return {\n      type: \"message\",\n      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n    };\n  }\n\n  var packetType = PACKET_TYPES_REVERSE[type];\n\n  if (!packetType) {\n    return ERROR_PACKET;\n  }\n\n  return encodedPacket.length > 1 ? {\n    type: PACKET_TYPES_REVERSE[type],\n    data: encodedPacket.substring(1)\n  } : {\n    type: PACKET_TYPES_REVERSE[type]\n  };\n};\n\nvar decodeBase64Packet = function decodeBase64Packet(data, binaryType) {\n  if (withNativeArrayBuffer) {\n    var decoded = decode(data);\n    return mapBinary(decoded, binaryType);\n  } else {\n    return {\n      base64: true,\n      data: data\n    }; // fallback for old browsers\n  }\n};\n\nvar mapBinary = function mapBinary(data, binaryType) {\n  switch (binaryType) {\n    case \"blob\":\n      return data instanceof ArrayBuffer ? new Blob([data]) : data;\n\n    case \"arraybuffer\":\n    default:\n      return data;\n    // assuming the data is already an ArrayBuffer\n  }\n};\n\nexport default decodePacket;","map":{"version":3,"sources":["D:/fl-carla/node_modules/engine.io-parser/build/esm/decodePacket.browser.js"],"names":["ERROR_PACKET","PACKET_TYPES_REVERSE","decode","withNativeArrayBuffer","ArrayBuffer","decodePacket","encodedPacket","binaryType","type","data","mapBinary","charAt","decodeBase64Packet","substring","packetType","length","decoded","base64","Blob"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,oBAAvB,QAAmD,cAAnD;AACA,SAASC,MAAT,QAAuB,iCAAvB;AACA,IAAMC,qBAAqB,GAAG,OAAOC,WAAP,KAAuB,UAArD;;AACA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACC,aAAD,EAAgBC,UAAhB,EAA+B;AAChD,MAAI,OAAOD,aAAP,KAAyB,QAA7B,EAAuC;AACnC,WAAO;AACHE,MAAAA,IAAI,EAAE,SADH;AAEHC,MAAAA,IAAI,EAAEC,SAAS,CAACJ,aAAD,EAAgBC,UAAhB;AAFZ,KAAP;AAIH;;AACD,MAAMC,IAAI,GAAGF,aAAa,CAACK,MAAd,CAAqB,CAArB,CAAb;;AACA,MAAIH,IAAI,KAAK,GAAb,EAAkB;AACd,WAAO;AACHA,MAAAA,IAAI,EAAE,SADH;AAEHC,MAAAA,IAAI,EAAEG,kBAAkB,CAACN,aAAa,CAACO,SAAd,CAAwB,CAAxB,CAAD,EAA6BN,UAA7B;AAFrB,KAAP;AAIH;;AACD,MAAMO,UAAU,GAAGb,oBAAoB,CAACO,IAAD,CAAvC;;AACA,MAAI,CAACM,UAAL,EAAiB;AACb,WAAOd,YAAP;AACH;;AACD,SAAOM,aAAa,CAACS,MAAd,GAAuB,CAAvB,GACD;AACEP,IAAAA,IAAI,EAAEP,oBAAoB,CAACO,IAAD,CAD5B;AAEEC,IAAAA,IAAI,EAAEH,aAAa,CAACO,SAAd,CAAwB,CAAxB;AAFR,GADC,GAKD;AACEL,IAAAA,IAAI,EAAEP,oBAAoB,CAACO,IAAD;AAD5B,GALN;AAQH,CA1BD;;AA2BA,IAAMI,kBAAkB,GAAG,SAArBA,kBAAqB,CAACH,IAAD,EAAOF,UAAP,EAAsB;AAC7C,MAAIJ,qBAAJ,EAA2B;AACvB,QAAMa,OAAO,GAAGd,MAAM,CAACO,IAAD,CAAtB;AACA,WAAOC,SAAS,CAACM,OAAD,EAAUT,UAAV,CAAhB;AACH,GAHD,MAIK;AACD,WAAO;AAAEU,MAAAA,MAAM,EAAE,IAAV;AAAgBR,MAAAA,IAAI,EAAJA;AAAhB,KAAP,CADC,CAC8B;AAClC;AACJ,CARD;;AASA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACD,IAAD,EAAOF,UAAP,EAAsB;AACpC,UAAQA,UAAR;AACI,SAAK,MAAL;AACI,aAAOE,IAAI,YAAYL,WAAhB,GAA8B,IAAIc,IAAJ,CAAS,CAACT,IAAD,CAAT,CAA9B,GAAiDA,IAAxD;;AACJ,SAAK,aAAL;AACA;AACI,aAAOA,IAAP;AAAa;AALrB;AAOH,CARD;;AASA,eAAeJ,YAAf","sourcesContent":["import { ERROR_PACKET, PACKET_TYPES_REVERSE } from \"./commons.js\";\r\nimport { decode } from \"./contrib/base64-arraybuffer.js\";\r\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\r\nconst decodePacket = (encodedPacket, binaryType) => {\r\n    if (typeof encodedPacket !== \"string\") {\r\n        return {\r\n            type: \"message\",\r\n            data: mapBinary(encodedPacket, binaryType)\r\n        };\r\n    }\r\n    const type = encodedPacket.charAt(0);\r\n    if (type === \"b\") {\r\n        return {\r\n            type: \"message\",\r\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\r\n        };\r\n    }\r\n    const packetType = PACKET_TYPES_REVERSE[type];\r\n    if (!packetType) {\r\n        return ERROR_PACKET;\r\n    }\r\n    return encodedPacket.length > 1\r\n        ? {\r\n            type: PACKET_TYPES_REVERSE[type],\r\n            data: encodedPacket.substring(1)\r\n        }\r\n        : {\r\n            type: PACKET_TYPES_REVERSE[type]\r\n        };\r\n};\r\nconst decodeBase64Packet = (data, binaryType) => {\r\n    if (withNativeArrayBuffer) {\r\n        const decoded = decode(data);\r\n        return mapBinary(decoded, binaryType);\r\n    }\r\n    else {\r\n        return { base64: true, data }; // fallback for old browsers\r\n    }\r\n};\r\nconst mapBinary = (data, binaryType) => {\r\n    switch (binaryType) {\r\n        case \"blob\":\r\n            return data instanceof ArrayBuffer ? new Blob([data]) : data;\r\n        case \"arraybuffer\":\r\n        default:\r\n            return data; // assuming the data is already an ArrayBuffer\r\n    }\r\n};\r\nexport default decodePacket;\r\n"]},"metadata":{},"sourceType":"module"}