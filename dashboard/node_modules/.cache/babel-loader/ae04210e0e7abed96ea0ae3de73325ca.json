{"ast":null,"code":"import parsePhoneNumber from '../parsePhoneNumber.js';\n/**\r\n * Matches a phone number object against a phone number string.\r\n * @param  {string} phoneNumberString\r\n * @param  {PhoneNumber} phoneNumber\r\n * @param  {object} metadata — Metadata JSON\r\n * @return {'INVALID_NUMBER'|'NO_MATCH'|'SHORT_NSN_MATCH'|'NSN_MATCH'|'EXACT_MATCH'}\r\n */\n\nexport default function matchPhoneNumberStringAgainstPhoneNumber(phoneNumberString, phoneNumber, metadata) {\n  // Parse `phoneNumberString`.\n  var phoneNumberStringContainsCallingCode = true;\n  var parsedPhoneNumber = parsePhoneNumber(phoneNumberString, metadata);\n  if (!parsedPhoneNumber) {\n    // If `phoneNumberString` didn't contain a country calling code\n    // then substitute it with the `phoneNumber`'s country calling code.\n    phoneNumberStringContainsCallingCode = false;\n    parsedPhoneNumber = parsePhoneNumber(phoneNumberString, {\n      defaultCallingCode: phoneNumber.countryCallingCode\n    }, metadata);\n  }\n  if (!parsedPhoneNumber) {\n    return 'INVALID_NUMBER';\n  } // Check that the extensions match.\n\n  if (phoneNumber.ext) {\n    if (parsedPhoneNumber.ext !== phoneNumber.ext) {\n      return 'NO_MATCH';\n    }\n  } else {\n    if (parsedPhoneNumber.ext) {\n      return 'NO_MATCH';\n    }\n  } // Check that country calling codes match.\n\n  if (phoneNumberStringContainsCallingCode) {\n    if (phoneNumber.countryCallingCode !== parsedPhoneNumber.countryCallingCode) {\n      return 'NO_MATCH';\n    }\n  } // Check if the whole numbers match.\n\n  if (phoneNumber.number === parsedPhoneNumber.number) {\n    if (phoneNumberStringContainsCallingCode) {\n      return 'EXACT_MATCH';\n    } else {\n      return 'NSN_MATCH';\n    }\n  } // Check if one national number is a \"suffix\" of the other.\n\n  if (phoneNumber.nationalNumber.indexOf(parsedPhoneNumber.nationalNumber) === 0 || parsedPhoneNumber.nationalNumber.indexOf(phoneNumber.nationalNumber) === 0) {\n    // \"A SHORT_NSN_MATCH occurs if there is a difference because of the\n    //  presence or absence of an 'Italian leading zero', the presence or\n    //  absence of an extension, or one NSN being a shorter variant of the\n    //  other.\"\n    return 'SHORT_NSN_MATCH';\n  }\n  return 'NO_MATCH';\n}","map":{"version":3,"sources":["../../source/findNumbers/matchPhoneNumberStringAgainstPhoneNumber.js"],"names":["parsePhoneNumber","matchPhoneNumberStringAgainstPhoneNumber","phoneNumberString","phoneNumber","metadata","phoneNumberStringContainsCallingCode","parsedPhoneNumber","defaultCallingCode","countryCallingCode","ext","number","nationalNumber","indexOf"],"mappings":"AAAA,OAAOA,gBAAP,MAA6B,wBAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,wCAAT,CAAkDC,iBAAlD,EAAqEC,WAArE,EAAkFC,QAAlF,EAA4F;EAC1G;EACA,IAAIC,oCAAoC,GAAG,IAA3C;EACA,IAAIC,iBAAiB,GAAGN,gBAAgB,CAACE,iBAAD,EAAoBE,QAApB,CAAxC;EACA,IAAI,CAACE,iBAAL,EAAwB;IACvB;IACA;IACAD,oCAAoC,GAAG,KAAvCA;IACAC,iBAAiB,GAAGN,gBAAgB,CAACE,iBAAD,EAAoB;MAAEK,kBAAkB,EAAEJ,WAAW,CAACK;IAAlC,CAApB,EAA4EJ,QAA5E,CAApCE;EACA;EACD,IAAI,CAACA,iBAAL,EAAwB;IACvB,OAAO,gBAAP;EACA,CAZyG,CAc1G;;EACA,IAAIH,WAAW,CAACM,GAAhB,EAAqB;IACpB,IAAIH,iBAAiB,CAACG,GAAlBH,KAA0BH,WAAW,CAACM,GAA1C,EAA+C;MAC9C,OAAO,UAAP;IACA;EACD,CAJD,MAIO;IACN,IAAIH,iBAAiB,CAACG,GAAtB,EAA2B;MAC1B,OAAO,UAAP;IACA;EACD,CAvByG,CAyB1G;;EACA,IAAIJ,oCAAJ,EAA0C;IACzC,IAAIF,WAAW,CAACK,kBAAZL,KAAmCG,iBAAiB,CAACE,kBAAzD,EAA6E;MAC5E,OAAO,UAAP;IACA;EACD,CA9ByG,CAgC1G;;EACA,IAAIL,WAAW,CAACO,MAAZP,KAAuBG,iBAAiB,CAACI,MAA7C,EAAqD;IACpD,IAAIL,oCAAJ,EAA0C;MACzC,OAAO,aAAP;IACA,CAFD,MAEO;MACN,OAAO,WAAP;IACA;EACD,CAvCyG,CAyC1G;;EACA,IACCF,WAAW,CAACQ,cAAZR,CAA2BS,OAA3BT,CAAmCG,iBAAiB,CAACK,cAArDR,CAAAA,KAAyE,CAAzEA,IACAG,iBAAiB,CAACK,cAAlBL,CAAiCM,OAAjCN,CAAyCH,WAAW,CAACQ,cAArDL,CAAAA,KAAyE,CAF1E,EAGE;IACD;IACA;IACA;IACA;IACA,OAAO,iBAAP;EACA;EAED,OAAO,UAAP;AACA","sourcesContent":["import parsePhoneNumber from '../parsePhoneNumber.js'\r\n\r\n/**\r\n * Matches a phone number object against a phone number string.\r\n * @param  {string} phoneNumberString\r\n * @param  {PhoneNumber} phoneNumber\r\n * @param  {object} metadata — Metadata JSON\r\n * @return {'INVALID_NUMBER'|'NO_MATCH'|'SHORT_NSN_MATCH'|'NSN_MATCH'|'EXACT_MATCH'}\r\n */\r\nexport default function matchPhoneNumberStringAgainstPhoneNumber(phoneNumberString, phoneNumber, metadata) {\r\n\t// Parse `phoneNumberString`.\r\n\tlet phoneNumberStringContainsCallingCode = true\r\n\tlet parsedPhoneNumber = parsePhoneNumber(phoneNumberString, metadata)\r\n\tif (!parsedPhoneNumber) {\r\n\t\t// If `phoneNumberString` didn't contain a country calling code\r\n\t\t// then substitute it with the `phoneNumber`'s country calling code.\r\n\t\tphoneNumberStringContainsCallingCode = false\r\n\t\tparsedPhoneNumber = parsePhoneNumber(phoneNumberString, { defaultCallingCode: phoneNumber.countryCallingCode }, metadata)\r\n\t}\r\n\tif (!parsedPhoneNumber) {\r\n\t\treturn 'INVALID_NUMBER'\r\n\t}\r\n\r\n\t// Check that the extensions match.\r\n\tif (phoneNumber.ext) {\r\n\t\tif (parsedPhoneNumber.ext !== phoneNumber.ext) {\r\n\t\t\treturn 'NO_MATCH'\r\n\t\t}\r\n\t} else {\r\n\t\tif (parsedPhoneNumber.ext) {\r\n\t\t\treturn 'NO_MATCH'\r\n\t\t}\r\n\t}\r\n\r\n\t// Check that country calling codes match.\r\n\tif (phoneNumberStringContainsCallingCode) {\r\n\t\tif (phoneNumber.countryCallingCode !== parsedPhoneNumber.countryCallingCode) {\r\n\t\t\treturn 'NO_MATCH'\r\n\t\t}\r\n\t}\r\n\r\n\t// Check if the whole numbers match.\r\n\tif (phoneNumber.number === parsedPhoneNumber.number) {\r\n\t\tif (phoneNumberStringContainsCallingCode) {\r\n\t\t\treturn 'EXACT_MATCH'\r\n\t\t} else {\r\n\t\t\treturn 'NSN_MATCH'\r\n\t\t}\r\n\t}\r\n\r\n\t// Check if one national number is a \"suffix\" of the other.\r\n\tif (\r\n\t\tphoneNumber.nationalNumber.indexOf(parsedPhoneNumber.nationalNumber) === 0 ||\r\n\t\tparsedPhoneNumber.nationalNumber.indexOf(phoneNumber.nationalNumber) === 0\r\n\t) {\r\n\t\t// \"A SHORT_NSN_MATCH occurs if there is a difference because of the\r\n\t\t//  presence or absence of an 'Italian leading zero', the presence or\r\n\t\t//  absence of an extension, or one NSN being a shorter variant of the\r\n\t\t//  other.\"\r\n\t\treturn 'SHORT_NSN_MATCH'\r\n\t}\r\n\r\n\treturn 'NO_MATCH'\r\n}"]},"metadata":{},"sourceType":"module"}