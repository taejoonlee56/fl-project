{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/tj/fl-carla/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\n\nvar socket_1 = require(\"./socket\");\n\nvar socket_io_parser_1 = require(\"socket.io-parser\");\n\nvar BroadcastOperator = /*#__PURE__*/function () {\n  function BroadcastOperator(adapter) {\n    var rooms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    var exceptRooms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, BroadcastOperator);\n\n    this.adapter = adapter;\n    this.rooms = rooms;\n    this.exceptRooms = exceptRooms;\n    this.flags = flags;\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @example\n   * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n   * io.to(\"room-101\").emit(\"foo\", \"bar\");\n   *\n   * // with an array of rooms (a client will be notified at most once)\n   * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n   *\n   * // with multiple chained calls\n   * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n   *\n   * @param room - a room, or an array of rooms\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n\n\n  _createClass(BroadcastOperator, [{\n    key: \"to\",\n    value: function to(room) {\n      var rooms = new Set(this.rooms);\n\n      if (Array.isArray(room)) {\n        room.forEach(function (r) {\n          return rooms.add(r);\n        });\n      } else {\n        rooms.add(room);\n      }\n\n      return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n\n  }, {\n    key: \"in\",\n    value: function _in(room) {\n      return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n\n  }, {\n    key: \"except\",\n    value: function except(room) {\n      var exceptRooms = new Set(this.exceptRooms);\n\n      if (Array.isArray(room)) {\n        room.forEach(function (r) {\n          return exceptRooms.add(r);\n        });\n      } else {\n        exceptRooms.add(room);\n      }\n\n      return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     */\n\n  }, {\n    key: \"compress\",\n    value: function compress(_compress) {\n      var flags = Object.assign({}, this.flags, {\n        compress: _compress\n      });\n      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new BroadcastOperator instance\n     */\n\n  }, {\n    key: \"volatile\",\n    get: function get() {\n      var flags = Object.assign({}, this.flags, {\n        volatile: true\n      });\n      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n\n  }, {\n    key: \"local\",\n    get: function get() {\n      var flags = Object.assign({}, this.flags, {\n        local: true\n      });\n      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */\n\n  }, {\n    key: \"timeout\",\n    value: function timeout(_timeout) {\n      var flags = Object.assign({}, this.flags, {\n        timeout: _timeout\n      });\n      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients\n     * io.emit(\"foo\", \"bar\");\n     *\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an acknowledgement expected from all connected clients\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(ev) {\n      var _this = this;\n\n      if (socket_1.RESERVED_EVENTS.has(ev)) {\n        throw new Error(\"\\\"\".concat(String(ev), \"\\\" is a reserved event name\"));\n      } // set up packet object\n\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var data = [ev].concat(args);\n      var packet = {\n        type: socket_io_parser_1.PacketType.EVENT,\n        data: data\n      };\n      var withAck = typeof data[data.length - 1] === \"function\";\n\n      if (!withAck) {\n        this.adapter.broadcast(packet, {\n          rooms: this.rooms,\n          except: this.exceptRooms,\n          flags: this.flags\n        });\n        return true;\n      }\n\n      var ack = data.pop();\n      var timedOut = false;\n      var responses = [];\n      var timer = setTimeout(function () {\n        timedOut = true;\n        ack.apply(_this, [new Error(\"operation has timed out\"), responses]);\n      }, this.flags.timeout);\n      var expectedServerCount = -1;\n      var actualServerCount = 0;\n      var expectedClientCount = 0;\n\n      var checkCompleteness = function checkCompleteness() {\n        if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {\n          clearTimeout(timer);\n          ack.apply(_this, [null, responses]);\n        }\n      };\n\n      this.adapter.broadcastWithAck(packet, {\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      }, function (clientCount) {\n        // each Socket.IO server in the cluster sends the number of clients that were notified\n        expectedClientCount += clientCount;\n        actualServerCount++;\n        checkCompleteness();\n      }, function (clientResponse) {\n        // each client sends an acknowledgement\n        responses.push(clientResponse);\n        checkCompleteness();\n      });\n      this.adapter.serverCount().then(function (serverCount) {\n        expectedServerCount = serverCount;\n        checkCompleteness();\n      });\n      return true;\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link fetchSockets} instead.\n     */\n\n  }, {\n    key: \"allSockets\",\n    value: function allSockets() {\n      if (!this.adapter) {\n        throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n      }\n\n      return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */\n\n  }, {\n    key: \"fetchSockets\",\n    value: function fetchSockets() {\n      var _this2 = this;\n\n      return this.adapter.fetchSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      }).then(function (sockets) {\n        return sockets.map(function (socket) {\n          if (socket instanceof socket_1.Socket) {\n            // FIXME the TypeScript compiler complains about missing private properties\n            return socket;\n          } else {\n            return new RemoteSocket(_this2.adapter, socket);\n          }\n        });\n      });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n\n  }, {\n    key: \"socketsJoin\",\n    value: function socketsJoin(room) {\n      this.adapter.addSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n\n  }, {\n    key: \"socketsLeave\",\n    value: function socketsLeave(room) {\n      this.adapter.delSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */\n\n  }, {\n    key: \"disconnectSockets\",\n    value: function disconnectSockets() {\n      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.adapter.disconnectSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      }, close);\n    }\n  }]);\n\n  return BroadcastOperator;\n}();\n\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */\n\nvar RemoteSocket = /*#__PURE__*/function () {\n  function RemoteSocket(adapter, details) {\n    _classCallCheck(this, RemoteSocket);\n\n    this.id = details.id;\n    this.handshake = details.handshake;\n    this.rooms = new Set(details.rooms);\n    this.data = details.data;\n    this.operator = new BroadcastOperator(adapter, new Set([this.id]));\n  }\n\n  _createClass(RemoteSocket, [{\n    key: \"emit\",\n    value: function emit(ev) {\n      var _this$operator;\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return (_this$operator = this.operator).emit.apply(_this$operator, [ev].concat(args));\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     */\n\n  }, {\n    key: \"join\",\n    value: function join(room) {\n      return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave(room) {\n      return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.operator.disconnectSockets(close);\n      return this;\n    }\n  }]);\n\n  return RemoteSocket;\n}();\n\nexports.RemoteSocket = RemoteSocket;","map":{"version":3,"sources":["/home/tj/fl-carla/node_modules/socket.io/dist/broadcast-operator.js"],"names":["Object","defineProperty","exports","value","RemoteSocket","BroadcastOperator","socket_1","require","socket_io_parser_1","adapter","rooms","Set","exceptRooms","flags","room","Array","isArray","forEach","r","add","to","compress","assign","volatile","local","timeout","ev","RESERVED_EVENTS","has","Error","String","args","data","packet","type","PacketType","EVENT","withAck","length","broadcast","except","ack","pop","timedOut","responses","timer","setTimeout","apply","expectedServerCount","actualServerCount","expectedClientCount","checkCompleteness","clearTimeout","broadcastWithAck","clientCount","clientResponse","push","serverCount","then","sockets","fetchSockets","map","socket","Socket","addSockets","delSockets","close","disconnectSockets","details","id","handshake","operator","emit","socketsJoin","socketsLeave"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\nconst socket_1 = require(\"./socket\");\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nclass BroadcastOperator {\n    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {\n        this.adapter = adapter;\n        this.rooms = rooms;\n        this.exceptRooms = exceptRooms;\n        this.flags = flags;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        const rooms = new Set(this.rooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => rooms.add(r));\n        }\n        else {\n            rooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        const exceptRooms = new Set(this.exceptRooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => exceptRooms.add(r));\n        }\n        else {\n            exceptRooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     */\n    compress(compress) {\n        const flags = Object.assign({}, this.flags, { compress });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new BroadcastOperator instance\n     */\n    get volatile() {\n        const flags = Object.assign({}, this.flags, { volatile: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        const flags = Object.assign({}, this.flags, { local: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        const flags = Object.assign({}, this.flags, { timeout });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients\n     * io.emit(\"foo\", \"bar\");\n     *\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an acknowledgement expected from all connected clients\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */\n    emit(ev, ...args) {\n        if (socket_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        // set up packet object\n        const data = [ev, ...args];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data,\n        };\n        const withAck = typeof data[data.length - 1] === \"function\";\n        if (!withAck) {\n            this.adapter.broadcast(packet, {\n                rooms: this.rooms,\n                except: this.exceptRooms,\n                flags: this.flags,\n            });\n            return true;\n        }\n        const ack = data.pop();\n        let timedOut = false;\n        let responses = [];\n        const timer = setTimeout(() => {\n            timedOut = true;\n            ack.apply(this, [new Error(\"operation has timed out\"), responses]);\n        }, this.flags.timeout);\n        let expectedServerCount = -1;\n        let actualServerCount = 0;\n        let expectedClientCount = 0;\n        const checkCompleteness = () => {\n            if (!timedOut &&\n                expectedServerCount === actualServerCount &&\n                responses.length === expectedClientCount) {\n                clearTimeout(timer);\n                ack.apply(this, [null, responses]);\n            }\n        };\n        this.adapter.broadcastWithAck(packet, {\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, (clientCount) => {\n            // each Socket.IO server in the cluster sends the number of clients that were notified\n            expectedClientCount += clientCount;\n            actualServerCount++;\n            checkCompleteness();\n        }, (clientResponse) => {\n            // each client sends an acknowledgement\n            responses.push(clientResponse);\n            checkCompleteness();\n        });\n        this.adapter.serverCount().then((serverCount) => {\n            expectedServerCount = serverCount;\n            checkCompleteness();\n        });\n        return true;\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link fetchSockets} instead.\n     */\n    allSockets() {\n        if (!this.adapter) {\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n        }\n        return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */\n    fetchSockets() {\n        return this.adapter\n            .fetchSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        })\n            .then((sockets) => {\n            return sockets.map((socket) => {\n                if (socket instanceof socket_1.Socket) {\n                    // FIXME the TypeScript compiler complains about missing private properties\n                    return socket;\n                }\n                else {\n                    return new RemoteSocket(this.adapter, socket);\n                }\n            });\n        });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsJoin(room) {\n        this.adapter.addSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsLeave(room) {\n        this.adapter.delSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(close = false) {\n        this.adapter.disconnectSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, close);\n    }\n}\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */\nclass RemoteSocket {\n    constructor(adapter, details) {\n        this.id = details.id;\n        this.handshake = details.handshake;\n        this.rooms = new Set(details.rooms);\n        this.data = details.data;\n        this.operator = new BroadcastOperator(adapter, new Set([this.id]));\n    }\n    emit(ev, ...args) {\n        return this.operator.emit(ev, ...args);\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     */\n    join(room) {\n        return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     */\n    leave(room) {\n        return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     */\n    disconnect(close = false) {\n        this.operator.disconnectSockets(close);\n        return this;\n    }\n}\nexports.RemoteSocket = RemoteSocket;\n"]},"metadata":{},"sourceType":"script"}